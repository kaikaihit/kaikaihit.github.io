<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhangkai&#39;s Blogs</title>
  
  <subtitle>内在的干劲、勤奋的工作态度和坚韧不拔的精神</subtitle>
  <link href="kaikaihit.github.io/atom.xml" rel="self"/>
  
  <link href="kaikaihit.github.io/"/>
  <updated>2020-09-09T08:45:18.072Z</updated>
  <id>kaikaihit.github.io/</id>
  
  <author>
    <name>kaikai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鲁绣本体建模</title>
    <link href="kaikaihit.github.io/2020/09/09/%E9%B2%81%E7%BB%A3%E6%9C%AC%E4%BD%93%E5%BB%BA%E6%A8%A1/"/>
    <id>kaikaihit.github.io/2020/09/09/%E9%B2%81%E7%BB%A3%E6%9C%AC%E4%BD%93%E5%BB%BA%E6%A8%A1/</id>
    <published>2020-09-09T06:39:23.000Z</published>
    <updated>2020-09-09T08:45:18.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鲁绣分类（Lu-Embroidery）"><a href="#鲁绣分类（Lu-Embroidery）" class="headerlink" title="鲁绣分类（Lu Embroidery）"></a>鲁绣分类（Lu Embroidery）</h2><table><thead><tr><th align="center">鲁绣品种</th><th align="center">产地</th></tr></thead><tbody><tr><td align="center">雕平绣工艺</td><td align="center">文登</td></tr><tr><td align="center">满工扣锁</td><td align="center">文登</td></tr><tr><td align="center">扣眼</td><td align="center">乳山</td></tr><tr><td align="center">梭子花边</td><td align="center">蓬莱</td></tr><tr><td align="center">棒槌花边</td><td align="center">栖霞</td></tr><tr><td align="center">钩针</td><td align="center">海阳</td></tr><tr><td align="center">即墨花边</td><td align="center">即墨</td></tr><tr><td align="center">网扣</td><td align="center">招远</td></tr><tr><td align="center">花边</td><td align="center">青州</td></tr><tr><td align="center">发丝绣</td><td align="center">济南</td></tr></tbody></table><a id="more"></a><h2 id="图案分类（Pattern）"><a href="#图案分类（Pattern）" class="headerlink" title="图案分类（Pattern）"></a>图案分类（Pattern）</h2><table><thead><tr><th align="center">类别名称</th><th align="center">包含图案</th></tr></thead><tbody><tr><td align="center">植物类</td><td align="center">梅、兰、菊、桃花、牡丹、荷花、花卉等花卉；竹子、松树、柳树、石榴、佛手、桃树</td></tr><tr><td align="center">动物类</td><td align="center">蝴蝶、蜻蜓等昆虫；凤凰、孔雀、鸳鸯、喜鹊等鸟类；熊猫、鹿、金鱼等动物在鲁绣上的运用</td></tr><tr><td align="center">几何图案</td><td align="center">运用点、线、面等元素组合成十字、方格、菱形等几何形，加之色彩的疏密组合表现，画面丰满、自由</td></tr><tr><td align="center">文字图案</td><td align="center">用字直抒胸臆</td></tr></tbody></table><h2 id="组织形式（Form）"><a href="#组织形式（Form）" class="headerlink" title="组织形式（Form）"></a>组织形式（Form）</h2><table><thead><tr><th align="center">Form_name</th></tr></thead><tbody><tr><td align="center">单独纹样</td></tr><tr><td align="center">适合图案</td></tr><tr><td align="center">连续图案</td></tr><tr><td align="center">综合图案</td></tr></tbody></table><h2 id="布的种类（Cloth）"><a href="#布的种类（Cloth）" class="headerlink" title="布的种类（Cloth）"></a>布的种类（Cloth）</h2><table><thead><tr><th align="center">name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">植物纤维布</td><td align="center">植物纤维布是各种纯棉、麻和棉麻交织布。一般棉纱做台布用21支纱布幅36、54、72英寸。后来做床上用品使用30、40、60、支纱等交织和斜纹布，布幅都是90英寸以上，布料细腻柔软。鲁绣雕平绣工艺用料多一些。</td></tr><tr><td align="center">动物纤维布</td><td align="center">动物纤维布包括丝绸、软缎、乔其纱、羊绒、法兰绒、纯毛呢料等。蜀绣、苏绣平绣多一些。</td></tr><tr><td align="center">化纤布</td><td align="center">化纤布不像棉麻毛质材料耐高温，选着绣花时绣线最好不用棉、丝线刺绣。适合做机绣、丝带绣、金银线盘肠绣、主修、亮片绣等。</td></tr><tr><td align="center">玻璃砂</td><td align="center">玻璃纱适合发绣、丝线绣、乱针绣、双面绣等。</td></tr></tbody></table><h2 id="绣线种类（Thread）"><a href="#绣线种类（Thread）" class="headerlink" title="绣线种类（Thread）"></a>绣线种类（Thread）</h2><table><thead><tr><th align="center">绣线种类Thread</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">纯棉细线</td><td align="center">用线通常40多个色系，每个色系6—9个色阶。40支纱2股，30支纱2股</td></tr><tr><td align="center">纯棉粗线</td><td align="center">通常为20或21支纱3股或4股。20/4、21/4有的是丝光了手绣线用作雕绣、平绣等。</td></tr><tr><td align="center">合股线</td><td align="center"></td></tr><tr><td align="center">麻线</td><td align="center"></td></tr><tr><td align="center">真丝线</td><td align="center">是中国南方独有的，只有中国才有。适合绣动物、花鸟效果极佳。</td></tr><tr><td align="center">机绣线</td><td align="center"></td></tr><tr><td align="center">毛线</td><td align="center">一般用在钩针、毛线绣、织毛衣用。有细毛线、粗毛线。用于绣花一般底布要厚实一些为好</td></tr><tr><td align="center">金银线</td><td align="center">一般适合做盘金绣，金银线质地比较脆，他不适宜做复杂图案。</td></tr><tr><td align="center">化纤线</td><td align="center"></td></tr></tbody></table><h2 id="绣花工具（Tool）"><a href="#绣花工具（Tool）" class="headerlink" title="绣花工具（Tool）"></a>绣花工具（Tool）</h2><table><thead><tr><th align="center">绣花工具Tool</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">针</td><td align="center">针鼻椭圆形，针尖越细越好</td></tr><tr><td align="center">剪刀</td><td align="center">弯头剪刀，直头剪刀</td></tr><tr><td align="center">花绷子</td><td align="center">方形、圆形；木制、竹制、塑料材质；大中小。圆形的花绷子有竹制和塑料的两种。</td></tr></tbody></table><p>圆形大号竹制、圆形中号竹制、圆形小号竹制、圆形大号塑料、圆形中号塑料、圆形小号塑料</p><p>方形大号木制、方形中号木制、方形小号木制、方形大号竹制、方形中号竹制、方形小号竹制</p><p>方形大号塑料、方形中号塑料、方形小号塑料</p><h2 id="刺绣针法（Stitch）"><a href="#刺绣针法（Stitch）" class="headerlink" title="刺绣针法（Stitch）"></a>刺绣针法（Stitch）</h2><table><thead><tr><th align="center">所属大类</th><th align="center">针法种类</th></tr></thead><tbody><tr><td align="center"><strong>线性</strong></td><td align="center">单针绣</td></tr><tr><td align="center"></td><td align="center">双针绣</td></tr><tr><td align="center"></td><td align="center">锁链绣</td></tr><tr><td align="center"></td><td align="center">麦穗绣</td></tr><tr><td align="center"></td><td align="center">盘金绣</td></tr><tr><td align="center"></td><td align="center">绗针绣</td></tr><tr><td align="center"><strong>花形</strong></td><td align="center">平针绣</td></tr><tr><td align="center"></td><td align="center">掺针绣</td></tr><tr><td align="center"></td><td align="center">垫绣</td></tr><tr><td align="center"></td><td align="center">雕绣</td></tr><tr><td align="center"></td><td align="center">长短针绣</td></tr><tr><td align="center"></td><td align="center">套针</td></tr><tr><td align="center"></td><td align="center">结子花绣</td></tr><tr><td align="center"></td><td align="center">影绣花</td></tr><tr><td align="center"></td><td align="center">扒针绣</td></tr><tr><td align="center"></td><td align="center">圈边绣</td></tr><tr><td align="center"><strong>叶子</strong></td><td align="center">单边水绣</td></tr><tr><td align="center"></td><td align="center">双边水绣</td></tr><tr><td align="center"></td><td align="center">松针绣</td></tr><tr><td align="center"></td><td align="center">散套叶绣</td></tr><tr><td align="center"></td><td align="center">编叶绣</td></tr><tr><td align="center"></td><td align="center">树叶绣</td></tr><tr><td align="center"></td><td align="center">水草绣</td></tr><tr><td align="center"><strong>开光纹样和花蕊</strong></td><td align="center">把锦绣</td></tr><tr><td align="center"></td><td align="center">连锦绣</td></tr><tr><td align="center"></td><td align="center">钱眼纹绣</td></tr><tr><td align="center"></td><td align="center">席纹绣</td></tr><tr><td align="center"></td><td align="center">瓦楞纹绣</td></tr><tr><td align="center"></td><td align="center">纳底纹绣</td></tr><tr><td align="center"></td><td align="center">打籽绣</td></tr><tr><td align="center"><strong>大面积的针法</strong></td><td align="center">直短针绣小乱针</td></tr><tr><td align="center"></td><td align="center">直长针绣大乱针</td></tr><tr><td align="center"></td><td align="center">直针绣长乱针</td></tr><tr><td align="center"><strong>补绣</strong></td><td align="center">绣补</td></tr><tr><td align="center"></td><td align="center">扦补绣</td></tr><tr><td align="center"></td><td align="center">锁补绣</td></tr></tbody></table><h2 id="三元组"><a href="#三元组" class="headerlink" title="三元组"></a>三元组</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909163912239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Protege构建结果"><a href="#Protege构建结果" class="headerlink" title="Protégé构建结果"></a>Protégé构建结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909163331396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="知识服务平台构建结果"><a href="#知识服务平台构建结果" class="headerlink" title="知识服务平台构建结果"></a>知识服务平台构建结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909164509190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;鲁绣分类（Lu-Embroidery）&quot;&gt;&lt;a href=&quot;#鲁绣分类（Lu-Embroidery）&quot; class=&quot;headerlink&quot; title=&quot;鲁绣分类（Lu Embroidery）&quot;&gt;&lt;/a&gt;鲁绣分类（Lu Embroidery）&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;鲁绣品种&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;产地&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;雕平绣工艺&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;文登&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;满工扣锁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;文登&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;扣眼&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;乳山&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;梭子花边&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;蓬莱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;棒槌花边&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;栖霞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;钩针&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;海阳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;即墨花边&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;即墨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;网扣&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;招远&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;花边&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;青州&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;发丝绣&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;济南&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="本体建模" scheme="kaikaihit.github.io/tags/%E6%9C%AC%E4%BD%93%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱</title>
    <link href="kaikaihit.github.io/2020/09/08/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <id>kaikaihit.github.io/2020/09/08/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</id>
    <published>2020-09-08T06:42:42.000Z</published>
    <updated>2020-09-09T00:25:16.491Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://www.zuozuovera.com/usr/uploads/2017/11/994330753.png" alt="知识图谱.png"></p><p><img data-src="https://www.zuozuovera.com/usr/uploads/2017/03/2017-03-20_231425.png" alt="img"></p><p><img data-src="https://pic4.zhimg.com/v2-a6e61bbaf7f67c30d9329d28c7872c34_r.jpg" alt="preview"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://www.zuozuovera.com/usr/uploads/2017/11/994330753.png&quot; alt=&quot;知识图谱.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://www.zuozuovera</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-08-31T13:45:17.000Z</published>
    <updated>2020-09-07T07:01:58.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>一个程序至少有一个进程，一个进程至少有一个线程。</p><ol><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p></li></ol><a id="more"></a><h2 id="如何杀死一个进程"><a href="#如何杀死一个进程" class="headerlink" title="如何杀死一个进程"></a>如何杀死一个进程</h2><p>kill pid</p><h2 id="socket编程的三种通信模型，BIO，NIO，AIO"><a href="#socket编程的三种通信模型，BIO，NIO，AIO" class="headerlink" title="socket编程的三种通信模型，BIO，NIO，AIO"></a>socket编程的三种通信模型，BIO，NIO，AIO</h2><p>阻塞，非阻塞，io多路复用，epoll支持文件符数目没有限制，fd集合只会从用户进程拷贝到内核一次，自己维护一个事件队列，不用每次遍历fd集合发现是否有就绪状态。</p><h2 id="操作系统里的内存碎片，有什么解决办法"><a href="#操作系统里的内存碎片，有什么解决办法" class="headerlink" title="操作系统里的内存碎片，有什么解决办法"></a>操作系统里的内存碎片，有什么解决办法</h2><p>内存碎片分为：内部碎片和外部碎片。</p><p>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p><p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p><h2 id="页面存储"><a href="#页面存储" class="headerlink" title="页面存储"></a>页面存储</h2><p>主存被等分成大小相等的片，称为主存块，又称为实页。</p><p>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2n ,通常为1KB、2KB、2n KB等</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h2&gt;&lt;p&gt;一个程序至少有一个进程，一个进程至少有一个线程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简而言之,一个程序至少有一个进程,一个进程至少有一个线程.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="操作系统" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="kaikaihit.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="kaikaihit.github.io/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>kaikaihit.github.io/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-08-31T08:33:07.000Z</published>
    <updated>2020-09-07T07:02:23.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI七层协议模型、TCP-IP四层模型和五层协议体系结构"><a href="#OSI七层协议模型、TCP-IP四层模型和五层协议体系结构" class="headerlink" title="OSI七层协议模型、TCP/IP四层模型和五层协议体系结构"></a>OSI七层协议模型、TCP/IP四层模型和五层协议体系结构</h2><p>OSI七层协议模型：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。</p><p>TCP/IP是四层协议模型：网络接口层、<strong>网际层、运输层和应用层。</strong></p><p>网络五层模型：物理层、数据链路层、网络层、运输层和应用层。</p><a id="more"></a><p><strong>1、物理层</strong></p><p>主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。</p><p><strong>2、数据链路层</strong></p><p>定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。</p><p><strong>3、网络层</strong></p><p>在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p><p><strong>4、传输层（TCP/UDP）</strong></p><p>定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议TCP，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）和UDP（用户数据报协议UDP，与TCP特性恰恰相反，用于传输可靠性要求不高、数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层的接收的数据进行分段和传输，到达目的地后再进行传输。常常把这一层数据叫做段。</p><p><strong>5、会话层</strong></p><p>通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者就受会话请求（设备之间需要相互认识可以是IP地址也可以是MAC地址或者主机名）。</p><p><strong>6、表示层</strong></p><p>可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台程序计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。</p><p><strong>7、应用层</strong></p><p>是最靠近用户的OSI层。这一层为用户的应用程序（如：电子邮件、文件传输和仿真终端）提供网络服务。</p><p>​    物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）</p><p>​    数据链路层：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）</p><p>​    <strong>网络层：</strong>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</p><p>​    <strong>传输层：</strong>TCP、UDP、SPX</p><p>​    会话层：NFS、SQL、NETBIOS、RPC</p><p>​    表示层：JPEG、MPEG、ASII</p><p>​    <strong>应用层：</strong>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p><strong>三次握手</strong></p><p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong></p><p>1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN(c)**。此时客户端处于 **SYN_Send</strong> 状态。</p><p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p><p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p><p>4、服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方就建立起了连接。</p><p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据</p><p><strong>四次挥手</strong></p><p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</p><p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</p><p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p><p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p><p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><h2 id="Http1-1和1-0的区别"><a href="#Http1-1和1-0的区别" class="headerlink" title="Http1.1和1.0的区别"></a>Http1.1和1.0的区别</h2><p><strong>1.缓存处理</strong></p><p>http1.0使用header里的if-Modified-Since，Expires来作为缓存的标准。</p><p>http1.1引入更多的缓存控制策略Entity tag等。</p><p><strong>2.带宽优化及网络连接的使用</strong></p><p>http1.0存在浪费带宽的情况，客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</p><p>http1.1在请求头引入了range头域，它允许只请求资源的某个部分。</p><p><strong>3.错误通知的处理</strong></p><p>http1.1新增了24个状态码</p><p><strong>4.长连接</strong></p><p>http1.1支持长连接和请求的流水线处理。</p><h2 id="http请求502和504的区别"><a href="#http请求502和504的区别" class="headerlink" title="http请求502和504的区别"></a>http请求502和504的区别</h2><p>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><p>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>http是明文传输、https是加密的安全传输</p><p>连接的端口不一样，http是80，https是443</p><p>http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输较安全。</p><h2 id="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程"><a href="#浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程" class="headerlink" title="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程"></a>浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</h2><p>1.DNS解析</p><p>2.TCP连接 </p><p>3.发送HTTP请求 </p><p>4.服务器处理请求并返回HTTP报文 </p><p>5.浏览器解析渲染页面</p><h2 id="负载均衡-反向代理的优点"><a href="#负载均衡-反向代理的优点" class="headerlink" title="负载均衡 反向代理的优点"></a>负载均衡 反向代理的优点</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</p><p>拥塞控制</p><p>滑动窗口</p><p>tcp/udp区别</p><p>DNS如何解析</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;OSI七层协议模型、TCP-IP四层模型和五层协议体系结构&quot;&gt;&lt;a href=&quot;#OSI七层协议模型、TCP-IP四层模型和五层协议体系结构&quot; class=&quot;headerlink&quot; title=&quot;OSI七层协议模型、TCP/IP四层模型和五层协议体系结构&quot;&gt;&lt;/a&gt;OSI七层协议模型、TCP/IP四层模型和五层协议体系结构&lt;/h2&gt;&lt;p&gt;OSI七层协议模型：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。&lt;/p&gt;
&lt;p&gt;TCP/IP是四层协议模型：网络接口层、&lt;strong&gt;网际层、运输层和应用层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络五层模型：物理层、数据链路层、网络层、运输层和应用层。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="计算机网络" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="kaikaihit.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="kaikaihit.github.io/2020/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>kaikaihit.github.io/2020/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-31T07:54:25.000Z</published>
    <updated>2020-09-07T07:02:37.113Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p><h2 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h2><p><strong>1.模型名称</strong></p><p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p><p><strong>2.问题</strong></p><p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p><p><strong>3.解决方案</strong></p><p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。</p><p><strong>4.效果</strong></p><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p><a id="more"></a><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式一共有<strong>23</strong>个，主要分为三大类。</p><p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><p>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><p>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;设计模式的基本要素&quot;&gt;&lt;a href=&quot;#设计模式的基本要素&quot; class=&quot;headerlink&quot; title=&quot;设计模式的基本要素&quot;&gt;&lt;/a&gt;设计模式的基本要素&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.模型名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="设计模式" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="kaikaihit.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法|高级算法</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-31T07:37:02.000Z</published>
    <updated>2020-09-07T07:02:59.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="id全局唯一且自增，如何实现"><a href="#id全局唯一且自增，如何实现" class="headerlink" title="id全局唯一且自增，如何实现"></a>id全局唯一且自增，如何实现</h2><p>如何在分布式集群中，生成全局唯一的ID</p><p>方法一：UUID</p><p>方法二：数据库自增主键</p><p><strong>方法三：SnowFlake雪花算法</strong></p><p>Twitter公司采用的一种算法，目的是在分布式系统中生成全局唯一且趋势递增的ID。</p><p>雪花ID生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成：</p><p><img data-src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGovUVwFkfA0yRdCYoer9mqxdkKsBd5aD96r6ygicrXlKjwmsIBCZpF4rrkUM7FR1U1zZdL4yjEF1Fw/640?wx_fmt=png" alt="640?wx_fmt=png"></p><a id="more"></a><p><strong>1位标识符</strong>：始终是0，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。</p><p><strong>41位时间戳</strong>：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的。</p><p><strong>10位机器标识码</strong>：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成。</p><p><strong>12位序列</strong>：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号</p><p>优点：</p><p>1.生成ID不依赖于DB，完全在内存中生成，高性能高可用。</p><p>2.ID呈趋势递增，后续插入索引树的时候性能较好。</p><p>缺点：</p><p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成id冲突，或者id乱序。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;id全局唯一且自增，如何实现&quot;&gt;&lt;a href=&quot;#id全局唯一且自增，如何实现&quot; class=&quot;headerlink&quot; title=&quot;id全局唯一且自增，如何实现&quot;&gt;&lt;/a&gt;id全局唯一且自增，如何实现&lt;/h2&gt;&lt;p&gt;如何在分布式集群中，生成全局唯一的ID&lt;/p&gt;
&lt;p&gt;方法一：UUID&lt;/p&gt;
&lt;p&gt;方法二：数据库自增主键&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三：SnowFlake雪花算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Twitter公司采用的一种算法，目的是在分布式系统中生成全局唯一且趋势递增的ID。&lt;/p&gt;
&lt;p&gt;雪花ID生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGovUVwFkfA0yRdCYoer9mqxdkKsBd5aD96r6ygicrXlKjwmsIBCZpF4rrkUM7FR1U1zZdL4yjEF1Fw/640?wx_fmt=png&quot; alt=&quot;640?wx_fmt=png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="高级算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构与算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="高级算法" scheme="kaikaihit.github.io/tags/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法|堆与栈</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E4%B8%8E%E6%A0%88/</id>
    <published>2020-08-31T07:16:29.000Z</published>
    <updated>2020-09-07T07:03:07.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存中的栈-stack-、堆-heap-和静态区-static-area-的用法"><a href="#内存中的栈-stack-、堆-heap-和静态区-static-area-的用法" class="headerlink" title="内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法"></a>内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。</p><a id="more"></a><h2 id="heap和stack有什么区别"><a href="#heap和stack有什么区别" class="headerlink" title="heap和stack有什么区别"></a>heap和stack有什么区别</h2><p><strong>heap堆</strong></p><p>是一个运行时数据区，类的对象从中分配空间。当new等指令建立，不需要代码显示的释放，由垃圾回收来负责。</p><p>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。</p><p>缺点：由于其优点，所以存取速度较慢。</p><p><strong>stack栈</strong></p><p>数据项插入和删除都只能在称为栈顶的一端完成，先进先出。栈中存放一些基本类型的变量和对象句柄。</p><p>优点：读取数据比堆块，仅次于寄存器，栈数据可以共享。</p><p>缺点：缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存中的栈-stack-、堆-heap-和静态区-static-area-的用法&quot;&gt;&lt;a href=&quot;#内存中的栈-stack-、堆-heap-和静态区-static-area-的用法&quot; class=&quot;headerlink&quot; title=&quot;内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法&quot;&gt;&lt;/a&gt;内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String str = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="堆与栈" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
    
    <category term="数据结构与算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E5%A0%86%E4%B8%8E%E6%A0%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="堆与栈" scheme="kaikaihit.github.io/tags/%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法|排序</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-31T06:24:43.000Z</published>
    <updated>2020-08-31T07:15:57.742Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://uploadfiles.nowcoder.com/images/20180927/308572_1538031578438_AEAC18AEF8824A88CF86B273C90F0BCC" alt="img"></p><a id="more"></a><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快排：快速排序有两个方向，左边的i下标一直往右走（当条件a[i] &lt;= a[center_index]时），其中center_index是中枢元素的数组下标，一般取为数组第0个元素。</p><p>而右边的j下标一直往左走（当a[j] &gt; a[center_index]时）。</p><p>如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。交换a[j]和a[center_index]，完成一趟快速排序。</p><h2 id="堆排序的原理"><a href="#堆排序的原理" class="headerlink" title="堆排序的原理"></a>堆排序的原理</h2><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><p>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</p><p>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。</p><p>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20180927/308572_1538031730696_9D37F61D193E7D36552FD03117135AE8" alt="img"></p><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>建立在归并操作上的一种有效的排序算法。采用分治法。</p><h2 id="冒泡排序的原理"><a href="#冒泡排序的原理" class="headerlink" title="冒泡排序的原理"></a>冒泡排序的原理</h2><p>循环比较相邻的两个数，较大的数放在后面</p><p><strong>冒泡排序代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mppx(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j+<span class="number">1</span>]&lt;nums[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">                    nums[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        array[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    array=mppx(array);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200831151301748.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://uploadfiles.nowcoder.com/images/20180927/308572_1538031578438_AEAC18AEF8824A88CF86B273C90F0BCC&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="排序" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="数据结构与算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E6%8E%92%E5%BA%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="排序" scheme="kaikaihit.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法|树</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/</id>
    <published>2020-08-31T04:34:43.000Z</published>
    <updated>2020-08-31T06:14:16.159Z</updated>
    
    <content type="html"><![CDATA[<p>链表和数组是线性存储结构。树结构是非线性存储结构。存储的是具有“一对多”关系的数据元素的集合。、</p><p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png" alt="img"></p><pre><code>                                                                              (A)                                                                     (B) </code></pre><a id="more"></a><p>（A）是使用树结构存储的集合{A,B,C,D,E,F,G, H,I,J,K,L,M}，对于数据A来说，和数据B、C、D有关系，对于数据B来说，和数据E、F有关系。这就是一对多的关系。</p><p>（B）很像实际生活中的树倒过来，所以称之为“树形存储结构”。</p><h2 id="树的结点"><a href="#树的结点" class="headerlink" title="树的结点"></a>树的结点</h2><p>结点：使用树结构存储的每一个数据元素都被称为“结点”</p><p>父结点：A是BCD的父节点</p><p>子结点：BCD是A的子节点</p><p>兄弟结点：KL是兄弟结点，EF是兄弟结点，HIJ是兄弟结点，BCD是兄弟结点</p><p>（树）根结点：（A）中的A元素是根结点</p><p>叶（子）结点：没有任何子结点的结点成为叶子结点，（A）中的KLFGIJM是叶结点。</p><h2 id="子树和空树"><a href="#子树和空树" class="headerlink" title="子树和空树"></a>子树和空树</h2><p>子树：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p><p>空树：空树中没有结点。</p><h2 id="结点的度和层次"><a href="#结点的度和层次" class="headerlink" title="结点的度和层次"></a>结点的度和层次</h2><p>结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度。</p><p>​                    一棵树的度是树内各结点的度的最大值，（A）树的度是3</p><p>结点的层次：一棵树的深度（高度）是树中结点所在的最大的层次，（A）树的深度是4.</p><h2 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h2><p>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</p><p>在有序树中，一个结点最左边的子树称为”第一个孩子”，最右边的称为”最后一个孩子”。</p><p>在（A）中，如果本身是一颗有序树，则以结点B为根结点的子树为整棵树的第一个孩子，以结点D为根结点的子树为整棵树的最后一个孩子。</p><h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p><h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><p>嵌套集合、凹入表示法、广义表。</p><hr><h2 id="二叉树和二叉树的性质"><a href="#二叉树和二叉树的性质" class="headerlink" title="二叉树和二叉树的性质"></a>二叉树和二叉树的性质</h2><p><strong>二叉树：</strong></p><p>1.本身是有序树。</p><p>2.树中包含的各个结点的度不能超过2，即只能是0，1或者2.</p><p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195I0M1.gif" alt="二叉树示意图"></p><p>图a)是一颗二叉树，图b)不是。</p><p><strong>性质：</strong><br>$$<br>1.二叉树中，第 i 层最多有2^i-1 个结点。<br>$$</p><p>$$<br>2.如果二叉树的深度为 K，那么此二叉树最多有 2^K-1个结点。<br>$$</p><p>$$<br>3.二叉树中，终端结点数（叶子结点数）为 n_0，度为 2 的结点数为 n_2，则 n_0=n_2+1。<br>$$</p><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p><p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif" alt="满二叉树示意图"></p><p><strong>性质：</strong><br>$$<br>具有 n 个节点的满二叉树的深度为 log_2(n+1)。<br>$$</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif" alt="完全二叉树示意图"></p><h2 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h2><p><strong>二叉树转完全二叉树</strong></p><p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS01056261L.png" alt="img"></p><p>图 1 中，左侧是普通二叉树，右侧是转化后的完全（满）二叉树。</p><p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</p><p>由普通二叉树转换来的完全二叉树。</p><p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS0105A9146.png" alt="img"></p><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>先序遍历</p><ol><li>访问根结点；</li><li>访问当前结点的左子树；</li><li>若当前结点无左子树，则访问当前节点的右子树。</li></ol><p>中序遍历</p><ol><li>访问当前结点的左子树；</li><li>访问根结点；</li><li>访问当前结点的右子树。</li></ol><p>后续遍历</p><ol><li>访问当前结点的左子树；</li><li>访问当前结点的右子树；</li><li>访问当前结点的根结点。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表和数组是线性存储结构。树结构是非线性存储结构。存储的是具有“一对多”关系的数据元素的集合。、&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                                                                              (A)                                                                     (B) &lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="树" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E6%A0%91/"/>
    
    <category term="数据结构与算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E6%A0%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="树" scheme="kaikaihit.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法|链表</title>
    <link href="kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <id>kaikaihit.github.io/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</id>
    <published>2020-08-31T01:44:20.000Z</published>
    <updated>2020-08-31T04:34:24.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><p>1.增加/删除/修改速度比数组快。</p><p>2.查找速度慢，查找时，需要循环链表访问。</p><p>3.如果进行<strong>频繁</strong>插入和删除操作，会导致速度很慢。</p><a id="more"></a><h2 id="链表实现代码"><a href="#链表实现代码" class="headerlink" title="链表实现代码"></a>链表实现代码</h2><p><strong>导包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p><strong>定义节点类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    ListNode()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带val的构造方法</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印链表：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(pHead.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        pHead=pHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">     ListNode p = pHead;</span><br><span class="line">     <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//删除头结点</span></span><br><span class="line">         p=p.next;</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         p=p.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     p.next=p.next.next;</span><br><span class="line">     <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">     ListNode q = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">     <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//在头结点前插入</span></span><br><span class="line">         q.next=pHead;</span><br><span class="line">         <span class="keyword">return</span> q;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode p = pHead;</span><br><span class="line">     <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             p=p.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     q.next=p.next;</span><br><span class="line">     p.next=q;</span><br><span class="line">     <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">createListNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点值以-1结束&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ListNode pHead= <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>((temp=scan.nextInt())==-<span class="number">1</span>)&#123;<span class="comment">//头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead.val=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p =pHead;</span><br><span class="line">        <span class="keyword">while</span>((temp=scan.nextInt())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode q = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            p.next=q;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(pHead.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            pHead=pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在某位置增加一个节点，pos=0表示在头结点前插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        ListNode q = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//在头结点前插入</span></span><br><span class="line">            q.next=pHead;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        q.next=p.next;</span><br><span class="line">        p.next=q;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除某个节点,pos=0,表示删除头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//删除头结点</span></span><br><span class="line">            p=p.next;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=p.next.next;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除排序后的重复节点(重复节点只留一个)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteReNode</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.val==p.next.val)&#123;</span><br><span class="line">                p.next=p.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除排序后的重复节点(重复节点都删除)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteReNodeAll</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;<span class="comment">//链表遍历指针</span></span><br><span class="line">        ListNode newHead=<span class="keyword">new</span> ListNode();<span class="comment">//用于存放不重复节点</span></span><br><span class="line">        ListNode q=newHead;<span class="comment">//新链表的构建指针</span></span><br><span class="line">        ListNode pre=p;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.val==p.next.val)&#123;<span class="comment">//如果当前节点后下一个节点相同，则p往后移</span></span><br><span class="line">                p=p.next;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>)&#123;<span class="comment">//如果当前节点的值和后一节点的值不同，则当前节点是有可能不是重复节点，判断pre是否等于p</span></span><br><span class="line">                <span class="keyword">if</span>(pre==p)&#123;<span class="comment">//如果pre==p,说明p当前节点不是重复节点，则将该节点加入newHead中</span></span><br><span class="line">                    q.next=<span class="keyword">new</span> ListNode(p.val);</span><br><span class="line">                    q=q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=p.next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果p.next为null</span></span><br><span class="line">                <span class="keyword">if</span>(p==pre)&#123;</span><br><span class="line">                    q.next=<span class="keyword">new</span> ListNode(pre.val);</span><br><span class="line">                    q=q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main op = <span class="keyword">new</span> Main();</span><br><span class="line">        ListNode pHead =  <span class="keyword">new</span> ListNode();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建链表&quot;</span>);</span><br><span class="line">        pHead=op.createListNode();</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;链表pos处增加节点&quot;</span>);</span><br><span class="line">        pHead=op.addNode(pHead, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表pos处节点&quot;</span>);</span><br><span class="line">        pHead=op.deleteNode(pHead, <span class="number">2</span>);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表的重复值，但是保留一个&quot;</span>);</span><br><span class="line">        op.deleteReNode(pHead);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表的重复值&quot;</span>);</span><br><span class="line">        pHead=op.deleteReNodeAll(pHead);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200831103309462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;链表的优缺点&quot;&gt;&lt;a href=&quot;#链表的优缺点&quot; class=&quot;headerlink&quot; title=&quot;链表的优缺点&quot;&gt;&lt;/a&gt;链表的优缺点&lt;/h2&gt;&lt;p&gt;1.增加/删除/修改速度比数组快。&lt;/p&gt;
&lt;p&gt;2.查找速度慢，查找时，需要循环链表访问。&lt;/p&gt;
&lt;p&gt;3.如果进行&lt;strong&gt;频繁&lt;/strong&gt;插入和删除操作，会导致速度很慢。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="链表" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="数据结构与算法" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/%E9%93%BE%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="链表" scheme="kaikaihit.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java Web基础</title>
    <link href="kaikaihit.github.io/2020/08/30/Java-Web%E5%9F%BA%E7%A1%80/"/>
    <id>kaikaihit.github.io/2020/08/30/Java-Web%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-30T11:14:15.000Z</published>
    <updated>2020-08-31T01:43:51.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA应用服务器"><a href="#JAVA应用服务器" class="headerlink" title="JAVA应用服务器"></a>JAVA应用服务器</h2><p>BEA WebLogic Server，</p><p>IBM WebSphere Application Server，</p><p>Oracle9i Application Server</p><p>jBoss，</p><p>Tomcat</p><a id="more"></a><h2 id="Assert断言"><a href="#Assert断言" class="headerlink" title="Assert断言"></a>Assert断言</h2><p>常见的调试方式，很多开发语言支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p><h2 id="1分钟之内只能处理1000个请求，怎么实现？"><a href="#1分钟之内只能处理1000个请求，怎么实现？" class="headerlink" title="1分钟之内只能处理1000个请求，怎么实现？"></a>1分钟之内只能处理1000个请求，怎么实现？</h2><p>实现方法：计数器、滑动窗口、漏桶法和令牌桶</p><p>a) 对所有用户访问的次数计数。 定义一个计时器，单位为一分钟。 如果超出次数，就拒绝该请求。 一分钟后， 次数刷新值为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在单位计数中判断List中数量是否超出限制即可。</p><p>b) 使用aop实现请求的限制， 在需要限制的请求方法上加上aop逻辑。</p><h2 id="JSP中的静态包含和动态包含的有哪些区别"><a href="#JSP中的静态包含和动态包含的有哪些区别" class="headerlink" title="JSP中的静态包含和动态包含的有哪些区别"></a>JSP中的静态包含和动态包含的有哪些区别</h2><p>静态包含是通过JSP的include指令包含页面。</p><p>动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面</p><p>&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file=”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page=”…”&gt;<br>&lt;jsp:param name=”…” value=”…” /&gt;<br></jsp:include></p><h2 id="表达式语言（EL）的隐式对象以及该对象的作用"><a href="#表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="表达式语言（EL）的隐式对象以及该对象的作用"></a>表达式语言（EL）的隐式对象以及该对象的作用</h2><p>EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）</p><h2 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h2><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p><h2 id="web-xml文件"><a href="#web-xml文件" class="headerlink" title="web.xml文件"></a>web.xml文件</h2><p>web.xml用于配置Web应用的相关信息</p><p>监听器、过滤器、Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。</p><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p><p>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。<br>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。<br>③HttpSessionListener：对Session的创建和销毁进行监听。</p><p>④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。<br>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。<br>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p><p>Session销毁：</p><p>1.session超时，从web.xml文件中通过<session-config>/<session-timeout>标签配置超时时间。</p><p>2.通过调用session对象的invalidate()方法使session失效。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。</p><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><p>Servlet 通过调用 init () 方法进行初始化。</p><p>Servlet 调用 service() 方法来处理客户端的请求。</p><p>Servlet 通过调用 destroy() 方法终止（结束）。</p><p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p><p>Servlet单实例，减少了产生servlet的开销；</p><h2 id="（转发）forward与（重定向）redirect区别"><a href="#（转发）forward与（重定向）redirect区别" class="headerlink" title="（转发）forward与（重定向）redirect区别"></a>（转发）forward与（重定向）redirect区别</h2><p>forward是转发，redirect是重定向</p><p><strong>1.地址栏显示不同</strong></p><p>forward是服务器请求，地址栏还是原来的地址</p><p>redirect是服务端根据逻辑，发送一个状态码，地址栏显示的是新的URL</p><p><strong>2.数据共享不同</strong></p><p>forward，转发页面和转发到的页面可以共享request里面的数据。</p><p>redirect，不能共享数据。</p><p><strong>3.运用场景不同</strong></p><p>forward：用于用户登录，根据角色转发到相应的模块。</p><p>redirect：用于用户注销登录时返回主页面和跳转到其它的网站等。</p><p><strong>4.效率不同</strong></p><p>forward：高</p><p>redirect：低</p><p>redirect的状态码是302</p><h2 id="redis的List能在什么场景下使用"><a href="#redis的List能在什么场景下使用" class="headerlink" title="redis的List能在什么场景下使用"></a>redis的List能在什么场景下使用</h2><p>Redis中的list的数据结构是双向链表，可以非常便捷的应用于消息队列（生产者/消费者模型）。消息的生产者只需要通过ipush将消息放入list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。</p><h2 id="AOF和RDB"><a href="#AOF和RDB" class="headerlink" title="AOF和RDB"></a>AOF和RDB</h2><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来存放。</p><h2 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h2><p>1.减少对数据库的读操作，数据库压力降低。</p><p>2.加快了响应速度。</p><h2 id="redis-读写速率快、性能好"><a href="#redis-读写速率快、性能好" class="headerlink" title="redis 读写速率快、性能好"></a>redis 读写速率快、性能好</h2><p>Redis是纯内存数据库，相对于读写磁盘，Hash查找可以达到每秒百万次的数量级。</p><h2 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h2><p>第一阶段：与master建立连接</p><p>第二阶段：向master发起同步请求（SYNC）</p><p>第三阶段：接受master发来的RDB数据</p><p>第四阶段：载入RDB文件</p><h2 id="DAO模式"><a href="#DAO模式" class="headerlink" title="DAO模式"></a>DAO模式</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。</p><p>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象）。前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p><h2 id="MVC各个部分需要的技术"><a href="#MVC各个部分需要的技术" class="headerlink" title="MVC各个部分需要的技术"></a>MVC各个部分需要的技术</h2><p>Model-View-Controller</p><p>Model：实现系统中的业务逻辑</p><p>View：用于与用户的交互。</p><p>Controller：是model与View之间沟通的桥梁。提供应用的处理过程。</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>1.get请求用来从服务器上获得资源，而post用来向服务器提交数据。</p><p>2.get时参数会显示在地址栏上，post的地址栏不会显示。</p><p>3.get传输收到url的限制，1024字节；而post可以传输大量的数据，上传文件通常使用post方式。</p><h2 id="J2EE中常用的名词进行解释"><a href="#J2EE中常用的名词进行解释" class="headerlink" title="J2EE中常用的名词进行解释"></a>J2EE中常用的名词进行解释</h2><p><strong>web 容器：</strong>给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题</p><p><strong>Web container：</strong>实现J2EE体系结构中Web组件协议的容器。</p><p><strong>EJB容器：</strong>Enterprise java bean 容器。更具有行业领域特色。</p><p><strong>JNDI：</strong>（Java Naming &amp; Directory Interface）JAVA命名目录服务</p><p><strong>JMS：</strong>（Java Message Service）JAVA消息服务</p><p><strong>JTA：</strong>（Java Transaction API）JAVA事务服务</p><p><strong>JAF：</strong>（Java Action FrameWork）JAVA安全认证框架</p><p><strong>RMI/IIOP:</strong> （Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务</p><h2 id="网站在架构上应当考虑哪些问题"><a href="#网站在架构上应当考虑哪些问题" class="headerlink" title="网站在架构上应当考虑哪些问题"></a>网站在架构上应当考虑哪些问题</h2><p><strong>1.分层</strong></p><p>分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统</p><p><strong>2.分割</strong></p><p>分割是对软件的纵向切分</p><p><strong>3.分布式</strong></p><p>网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快</p><p><strong>4.集群</strong></p><p>集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持</p><p><strong>5.缓存</strong></p><p>缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。</p><p>CDN/反向代理/热点数据</p><p><strong>6.异步</strong></p><p>异步是实现软件实体之间解耦合的又一重要手段。是典型的生产者消费者模式。</p><p><strong>7.冗余</strong></p><p>各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JAVA应用服务器&quot;&gt;&lt;a href=&quot;#JAVA应用服务器&quot; class=&quot;headerlink&quot; title=&quot;JAVA应用服务器&quot;&gt;&lt;/a&gt;JAVA应用服务器&lt;/h2&gt;&lt;p&gt;BEA WebLogic Server，&lt;/p&gt;
&lt;p&gt;IBM WebSphere Application Server，&lt;/p&gt;
&lt;p&gt;Oracle9i Application Server&lt;/p&gt;
&lt;p&gt;jBoss，&lt;/p&gt;
&lt;p&gt;Tomcat&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Java Web" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java-Web/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Web" scheme="kaikaihit.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java EE基础|Struts</title>
    <link href="kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Struts/"/>
    <id>kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Struts/</id>
    <published>2020-08-30T10:37:23.000Z</published>
    <updated>2020-08-30T11:14:17.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STRUTS的应用场景"><a href="#STRUTS的应用场景" class="headerlink" title="STRUTS的应用场景"></a>STRUTS的应用场景</h2><p>Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。采用Struts开发出基于MVC（Model、View和Controller）设计模式的应用架构。有如下功能：</p><p>包含一个controller servlet，能将用户的请求发送到相应的Action对象。</p><p>JSP自由Tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。</p><p>提供一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STRUTS的应用场景&quot;&gt;&lt;a href=&quot;#STRUTS的应用场景&quot; class=&quot;headerlink&quot; title=&quot;STRUTS的应用场景&quot;&gt;&lt;/a&gt;STRUTS的应用场景&lt;/h2&gt;&lt;p&gt;Struts是采用Java Servlet/JavaServer P</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Struts" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Struts/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Struts" scheme="kaikaihit.github.io/tags/Struts/"/>
    
  </entry>
  
  <entry>
    <title>Java EE基础|Hibernate</title>
    <link href="kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Hibernate/"/>
    <id>kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Hibernate/</id>
    <published>2020-08-30T10:37:13.000Z</published>
    <updated>2020-08-30T11:03:43.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实体对象的三种形式以及转换关系"><a href="#实体对象的三种形式以及转换关系" class="headerlink" title="实体对象的三种形式以及转换关系"></a>实体对象的三种形式以及转换关系</h2><p>瞬时态、持久态、游状态</p><p>瞬时态：new一个对象，这个对象处于瞬时态。</p><p>持久态：实例在数据库中有对应的记录。Session进行了Save、saveOrUpdate()、persist()、merge()方法把瞬时态转成持久态。</p><p>游离态：对象不在持久化管理之内，所以处于游离态。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。Session进行了close()、clear()、evict()或flush()后，由持久态变成游离态。</p><h2 id="锁的机制的作用"><a href="#锁的机制的作用" class="headerlink" title="锁的机制的作用"></a>锁的机制的作用</h2><p>有些业务逻辑在执行过程中要求对数据进行排他性的访问，需要通过一些机制保证在此过程中数据被锁住不会被外接修改，这就是锁机制。</p><p>Hibernate支持悲观锁和乐观锁两种锁机制。</p><p>悲观锁，在数据处理过程中极有可能存在修改数据的并发事务，于是将处理的数据设置为锁定状态。</p><p>乐观锁，对并发事务持乐观态度，通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响</p><p>Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实体对象的三种形式以及转换关系&quot;&gt;&lt;a href=&quot;#实体对象的三种形式以及转换关系&quot; class=&quot;headerlink&quot; title=&quot;实体对象的三种形式以及转换关系&quot;&gt;&lt;/a&gt;实体对象的三种形式以及转换关系&lt;/h2&gt;&lt;p&gt;瞬时态、持久态、游状态&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Hibernate" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Hibernate/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Hibernate" scheme="kaikaihit.github.io/tags/Hibernate/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java EE基础|Spring</title>
    <link href="kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Spring/"/>
    <id>kaikaihit.github.io/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Spring/</id>
    <published>2020-08-30T02:34:03.000Z</published>
    <updated>2020-08-30T10:37:00.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring的自动装配"><a href="#Spring的自动装配" class="headerlink" title="Spring的自动装配"></a>Spring的自动装配</h2><p>- no：不进行自动装配，手动设置Bean的依赖关系。<br>- byName：根据Bean的名字进行自动装配。<br>- byType：根据Bean的类型进行自动装配。<br>- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。<br>- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p><a id="more"></a><h2 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h2><p>Spring2.X针对WebApplicationContext新增了3个作用域。分别是request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p><h2 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h2><p><strong>IOC控制反转</strong></p><p>Inversion of Control。控制反转是把传统上由程序代码直接操作的对象交给容器，通过容器来实现对象组件的装配和管理。控制反转就是对组件对象控制权的转移，从程序代码本身转移到外部容器，由容器来创建对象并管理对象之间的依赖关系。</p><p><strong>DI依赖注入</strong></p><p>Dependency Injection。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由<strong>容器负责</strong></p><h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p><strong>BeanFactory：</strong></p><p>是spring比较原始的Factory。无法支持spring插件，例如AOP、Web等功能。</p><p>多用于移动设备的开发。</p><p><strong>ApplicationContext：</strong></p><p>是BeanFactory的子接口，因为古老的BeanFactory无法满足不断更新的spring需求，于是ApplicationContext就代替了BeanFactory的工作。</p><h2 id="springIOC原理"><a href="#springIOC原理" class="headerlink" title="springIOC原理"></a>springIOC原理</h2><p>IOC控制反转：是spring的核心，贯穿始终，对于spring框架来说，由spring负责控制对象的生命周期和对象间的关系。</p><p>实现IOC的步骤：</p><p>定义用来描述bean的配置的Java类</p><p>解析bean的配置，将bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术。</p><p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java反射机制实例化对象，将实例化的对象保存在另外一个Map中即可。</p><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><p>1.Set注入</p><p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）。</p><p>2.构造器注入</p><p>通过将@Autowired注解放在构造器上来完成构造器注入，默认构造器参数通过类型自动装配</p><p>3.接口注入</p><h2 id="autowired-和resource区别"><a href="#autowired-和resource区别" class="headerlink" title="autowired 和resource区别"></a>autowired 和resource区别</h2><p>共同点：都可以写在字段和setter方法上。两者如果都写在字段上，就不需要再写setter方法。</p><p>不同点：</p><p><strong>@Autowired</strong></p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p>@Autowired注解是<strong>按照类型（byType）装配依赖对象</strong>，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p><p><strong>@Resource</strong></p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>创建，准备，使用，销毁</p><p><img data-src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt="img"></p><p><img data-src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt="img"></p><h2 id="IOC和AOP是什么"><a href="#IOC和AOP是什么" class="headerlink" title="IOC和AOP是什么"></a>IOC和AOP是什么</h2><p><strong>IOC</strong>是控制反转，与依赖注入DI是一个概念。依赖注入的三种方式：接口注入、构造器注入和Setter注入</p><p>IOC的目的：</p><p>​    （1）脱开、降低类之间的耦合；</p><p>​    （2）倡导面向接口编程、实施依赖倒换原则； </p><p>​    （3）提高系统可插入、可测试、可修改等特性。</p><p><strong>AOP</strong>是面向切面编程：</p><p>​    传统的方式是OOP。Object Oriented Programming面向对象编程，引入封装、继承和多态。允许开发者定义纵向的关系，但是会使很多代码重复，不利于各个模块的重用。</p><h2 id="Spring支持的事务管理"><a href="#Spring支持的事务管理" class="headerlink" title="Spring支持的事务管理"></a>Spring支持的事务管理</h2><p>Spring支持编程式事务管理和声明式事务管理</p><p>事务分为全局事务和局部事务。</p><p><strong>全局事务由应用服务器管理</strong>，需要底层服务器JTA支持（如WebLogic、WildFly等）。</p><p>局部事务和底层采用的持久化方案有关，例如：使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p><h2 id="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）"><a href="#AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）" class="headerlink" title="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）"></a>AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）</h2><p>AOP，指面向切面编程。作为面向对象的一种不愁，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等。实现的关键在于AOP框架自动创建的AOP代理，AOP代理分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。</p><p>连接点：程序执行的某个特定位置。</p><p>切点：一个切点可以匹配多个连接点</p><p>增强：增强是织入到目标类连接点上的一段程序代码</p><p>引介：是一种特殊的增强。</p><p>织入：将增强添加到目标类具体连接点上的过程。编译器织入、装载器织入和运行时织入。</p><p>切面：切面由切点和增强（引介）组成的。包括了对横切关注功能的定义，也包括了对连接点的定义。</p><h2 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h2><p>Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。</p><h2 id="Spring框架为企业级开发带来的好处"><a href="#Spring框架为企业级开发带来的好处" class="headerlink" title="Spring框架为企业级开发带来的好处"></a>Spring框架为企业级开发带来的好处</h2><p>非侵入式：支持基于POJO（不继承其它类，也不实现其它接口的Java基础类）的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。</p><p>IOC控制反转</p><p>AOP面向切面编程</p><p>MVC框架，为Web表示层提供更好的解决方案。</p><p>事物管理：Spring以宽广的胸怀接纳多种持久化技术，并为其提供了声明式的实务管理，在不需要任何代码的情况下就能完成事务管理。</p><h2 id="Struts拦截器和Spring-AOP有什么区别"><a href="#Struts拦截器和Spring-AOP有什么区别" class="headerlink" title="Struts拦截器和Spring AOP有什么区别"></a>Struts拦截器和Spring AOP有什么区别</h2><p>拦截器是AOP的一种实现，struts2 拦截器采用xwork2的interceptor。而spring的AOP基于IoC基础,其底层采用动态代理与CGLIB代理两种方式结合的实现方式</p><h2 id="简单介绍一下Spring"><a href="#简单介绍一下Spring" class="headerlink" title="简单介绍一下Spring"></a>简单介绍一下Spring</h2><p>Spring是一个轻量级框架，可以一站式构建你的企业级应用。</p><p>Spring的模块大概分为6个。分别是：</p><p>1、Core Container（Spring的核心）【重要】</p><p>2、AOP（面向切面变成）【重要】</p><p>3、Messaging（消息发送的支持）</p><p>4、Data Access/Integration（数据访问和集成）</p><p>5、Web（主要是SpringWeb内容，包括MVC）【重要】</p><p>6、Test（Spring测试支持，包含JUint等测试单元的支持） </p><p>7、Instrumentation（设备支持，比如Tomcat的支持）</p><h2 id="持久层要考虑的问题有哪些，有哪些持久层框架"><a href="#持久层要考虑的问题有哪些，有哪些持久层框架" class="headerlink" title="持久层要考虑的问题有哪些，有哪些持久层框架"></a>持久层要考虑的问题有哪些，有哪些持久层框架</h2><p><strong>持久层设计的目标包括：</strong><br>- 数据存储逻辑的分离，提供抽象化的数据访问接口。<br>- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。<br>- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。<br>- 数据抽象，提供更面向对象的数据操作。</p><p><strong>持久层框架有：</strong><br>- Hibernate<br>- MyBatis<br>- TopLink<br>- Guzz<br>- jOOQ<br>- Spring Data<br>- ActiveJDBC</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Spring的自动装配&quot;&gt;&lt;a href=&quot;#Spring的自动装配&quot; class=&quot;headerlink&quot; title=&quot;Spring的自动装配&quot;&gt;&lt;/a&gt;Spring的自动装配&lt;/h2&gt;&lt;p&gt;- no：不进行自动装配，手动设置Bean的依赖关系。&lt;br&gt;- byName：根据Bean的名字进行自动装配。&lt;br&gt;- byType：根据Bean的类型进行自动装配。&lt;br&gt;- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。&lt;br&gt;- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Spring" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Spring/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Spring" scheme="kaikaihit.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|IO和NIOAIO</title>
    <link href="kaikaihit.github.io/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-IO%E5%92%8CNIOAIO/"/>
    <id>kaikaihit.github.io/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-IO%E5%92%8CNIOAIO/</id>
    <published>2020-08-29T12:15:35.000Z</published>
    <updated>2020-08-30T02:33:34.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA中有几种类型的流"><a href="#JAVA中有几种类型的流" class="headerlink" title="JAVA中有几种类型的流"></a>JAVA中有几种类型的流</h2><p>字节流，字符流</p><p>字节流继承于InputStream和OutputStream</p><p>字符流继承于InputStreamReader和OutputStreamWriter.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JAVA中有几种类型的流&quot;&gt;&lt;a href=&quot;#JAVA中有几种类型的流&quot; class=&quot;headerlink&quot; title=&quot;JAVA中有几种类型的流&quot;&gt;&lt;/a&gt;JAVA中有几种类型的流&lt;/h2&gt;&lt;p&gt;字节流，字符流&lt;/p&gt;
&lt;p&gt;字节流继承于InputStre</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="IO" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/IO/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="IO" scheme="kaikaihit.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|GC</title>
    <link href="kaikaihit.github.io/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-GC/"/>
    <id>kaikaihit.github.io/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-GC/</id>
    <published>2020-08-29T08:18:58.000Z</published>
    <updated>2020-08-29T12:15:36.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收的优点以及原理。"><a href="#垃圾回收的优点以及原理。" class="headerlink" title="垃圾回收的优点以及原理。"></a>垃圾回收的优点以及原理。</h2><p><strong>优点：</strong></p><p>1.java中的重大特点就是引用了垃圾回收机制，使得java程序员在编写程序的时候不用考虑内存管理。</p><p>2.有垃圾回收机制，java中的对象不再有“作用域的概念，只有对象的引用才有”作用域“。</p><p>3.垃圾回收机制有效的防止内存泄露，有效的使用可以使用的内存。</p><p><strong>工作原理：</strong></p><p>当创建对象时，GC就开始监视这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理heap（堆）中的素有对象。通过这种方式确定哪些对象时“可达的”，哪些是“不可达的”。</p><p>垃圾回收机制通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清理，我们虽然可以调用System.gc()让垃圾回收器运行，但依旧无法保证GC一定会执行。</p><p>GC，Gabage Collection，可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h2 id="JVM怎么确定哪些对象应该进行回收？"><a href="#JVM怎么确定哪些对象应该进行回收？" class="headerlink" title="JVM怎么确定哪些对象应该进行回收？"></a>JVM怎么确定哪些对象应该进行回收？</h2><p>JVM 的垃圾回收器主要关注的是堆上创建的实例对象，在每次对这些对象进行回收前，需要确定哪些对象是可以去进行回收的。主要由下面两种方法。</p><p><strong>1.引用计数算法</strong></p><p>给对象添加一个引用计数器，当有一个地方引用它，计数器值加1；当引用失效时，计数器值减1。任何时候计数器值为0表示这个对象可以被回收了。</p><p>优点：</p><p>判断效率高，实现简单。</p><p>缺点：</p><p>难以解决对象之间相互循序引用的问题。</p><p><strong>2.可达性分析算法</strong></p><p>可作为GC Roots的对象有：</p><ol><li>虚拟机栈中的引用的对象</li><li>方法区的静态变量和常量引用的对象</li><li>本地方法栈中JNI引用的对象。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;垃圾回收的优点以及原理。&quot;&gt;&lt;a href=&quot;#垃圾回收的优点以及原理。&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收的优点以及原理。&quot;&gt;&lt;/a&gt;垃圾回收的优点以及原理。&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="GC" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/GC/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="GC" scheme="kaikaihit.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|JVM</title>
    <link href="kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-JVM/"/>
    <id>kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-JVM/</id>
    <published>2020-08-28T12:20:14.000Z</published>
    <updated>2020-08-29T08:18:47.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM加载class文件的原理"><a href="#JVM加载class文件的原理" class="headerlink" title="JVM加载class文件的原理"></a>JVM加载class文件的原理</h2><p>JVM中类的装载是由ClassLoader和它的子类来实现的，Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><p>类装载方式，有两种。</p><p>隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。</p><p>显示装载：通过class.forname()等方法，显示加载需要的类，隐式加载与显式加载的区别：两者本质是一样的。</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>可执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p><p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者重写编译。Java虚拟机让这个变为可能。</p><p>（1）堆内存分配</p><p>JVM初始内存由-Xms指定，默认是物理内存的1/64；JVM最大分配内存由-Xms指定，默认是物理内存的1/4。默认空余堆内存小 于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC后调整堆的大小</p><p>（2）非堆内存分配</p><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p><p>（3）VM最大内存</p><p>JVM内存限制于实际的最大物理内存，结社物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。32位处理器虽然可控内存空间有4GB。但是具体的操作系统会给一个限制，这个限制一般是2GB~3GB（一般来说Windows系统下为1.5G-2G，Linux系 统下为2G-3G），而64bit以上的处理器就不会有限制了。</p><p>（4）几个不同公司不同版本JVM最大堆内存</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20180926/308572_1537966762062_914FBB519FF1ACBAF602B2DCBD5184D6" alt="img"></p><h2 id="哪些可作为Root对象"><a href="#哪些可作为Root对象" class="headerlink" title="哪些可作为Root对象"></a>哪些可作为Root对象</h2><p>\1. 虚拟机栈中的引用对象<br>\2. 本地方法栈中JNI引用对象<br>\3. 方法区中类静态属性引用的对象<br>\4. 方法区中常量引用对象（如字符串常量池）<br>\5. 被同步锁持有的对象<br>\6. 内部引用（如基本数据类型对应的class对象、常驻的异常对象NullPointerException等、系统类加载器）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM加载class文件的原理&quot;&gt;&lt;a href=&quot;#JVM加载class文件的原理&quot; class=&quot;headerlink&quot; title=&quot;JVM加载class文件的原理&quot;&gt;&lt;/a&gt;JVM加载class文件的原理&lt;/h2&gt;&lt;p&gt;JVM中类的装载是由ClassLoa</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="JVM" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/JVM/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="JVM" scheme="kaikaihit.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|线程</title>
    <link href="kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B/"/>
    <id>kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-28T08:58:45.000Z</published>
    <updated>2020-08-28T12:20:05.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的基本状态以及状态之间的关系"><a href="#线程的基本状态以及状态之间的关系" class="headerlink" title="线程的基本状态以及状态之间的关系"></a>线程的基本状态以及状态之间的关系</h2><p>运行态：Running</p><p>就绪态：Runnable，万事俱备，只欠CPU</p><p>阻塞状态：Blocked。调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p><h2 id="进程、线程和协程的区别"><a href="#进程、线程和协程的区别" class="headerlink" title="进程、线程和协程的区别"></a>进程、线程和协程的区别</h2><p>进程是系统进行资源分配和调用的基本单位，每一个进程都有它自己的内存空间和系统资源。</p><p>线程是进程的执行单位或者执行路线，进程也是CPU调度的基本单位。</p><p>协程是用户态的轻量级线程。</p><p>先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题<br>多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大<br>多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行<br>协程以后主要用在网络爬虫和网络请求，开辟一个协程大概需要5k空间，开辟一个线程需要512k空间， 开辟一个进程占用资源最多</p><h2 id="举例说明同步和异步"><a href="#举例说明同步和异步" class="headerlink" title="举例说明同步和异步"></a>举例说明同步和异步</h2><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p><h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争</p><h2 id="线程从创建到死亡的几种状态都有哪些"><a href="#线程从创建到死亡的几种状态都有哪些" class="headerlink" title="线程从创建到死亡的几种状态都有哪些"></a>线程从创建到死亡的几种状态都有哪些</h2><p><img data-src="https://uploadfiles.nowcoder.com/images/20190908/93694598_1567901669525_2E1604194BEFDDB0EE43167B50B364AB" alt="img"></p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。</p><p>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><h2 id="AQS的理解"><a href="#AQS的理解" class="headerlink" title="AQS的理解"></a>AQS的理解</h2><p>AbstractQueuedSynchronizer简称AQS。是实现锁的框架。</p><p>实现的关键是：先进先出的队列、state状态。</p><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>支持并发、解耦</p><p>生产者消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程的基本状态以及状态之间的关系&quot;&gt;&lt;a href=&quot;#线程的基本状态以及状态之间的关系&quot; class=&quot;headerlink&quot; title=&quot;线程的基本状态以及状态之间的关系&quot;&gt;&lt;/a&gt;线程的基本状态以及状态之间的关系&lt;/h2&gt;&lt;p&gt;运行态：Running&lt;/p</summary>
      
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Java线程" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="线程" scheme="kaikaihit.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|集合</title>
    <link href="kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>kaikaihit.github.io/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</id>
    <published>2020-08-28T03:01:13.000Z</published>
    <updated>2020-08-28T08:58:32.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List、Map、Set的区别"><a href="#List、Map、Set的区别" class="headerlink" title="List、Map、Set的区别"></a>List、Map、Set的区别</h2><p>list：有序访问、索引访问，可以重复<br>set(HashSet、LinkedHashSet 或者 TreeSet)：去重<br>map：键值存储</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20200215/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9" alt="img"></p><p><img data-src="https://upload-images.jianshu.io/upload_images/5959612-31df64b17fb83cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1018/format/webp" alt="img"></p><a id="more"></a><p>List：</p><blockquote><p>1.可以允许重复的对象。<br>2.可以插入多个null元素。<br>3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。<br>4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p></blockquote><p>Set：</p><blockquote><p>1 .不允许重复对象</p><p>2.无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</p><p>3.只允许一个 null 元素</p><p>4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p></blockquote><p><img data-src="https://upload-images.jianshu.io/upload_images/5959612-bb4adde83f977ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/660/format/webp" alt="img"></p><p>Map：</p><blockquote><p>1.Map不是collection的子接口或者实现类。Map是一个接口。</p><p>2.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p><p>3.TreeMap 也通过 Comparator  或者 Comparable 维护了一个排序顺序。</p><p>4.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p><p>5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p></blockquote><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别</h2><p>Iterator的安全失败是基于对底层集合做拷贝，它不受源集合上修改的影响。</p><p>java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的</p><p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h2 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h2><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：<strong>增加元素，替换元素，获取前一个和后一个元素的索引</strong>，等等。</p><h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口。</p><p>Java集合类框架的基本接口有哪些？</p><p>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><h2 id="TreeMap的底层实现"><a href="#TreeMap的底层实现" class="headerlink" title="TreeMap的底层实现"></a>TreeMap的底层实现</h2><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。</p><p>红黑树性质：</p><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。</p><p>性质1：每个节点要么是黑色，要么是红色。</p><p>性质2：根节点是黑色。</p><p>性质3：每个叶子节点（NIL）是黑色。</p><p>性质4：每个红色结点的两个子结点一定都是黑色。</p><p><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></p><p>三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;List、Map、Set的区别&quot;&gt;&lt;a href=&quot;#List、Map、Set的区别&quot; class=&quot;headerlink&quot; title=&quot;List、Map、Set的区别&quot;&gt;&lt;/a&gt;List、Map、Set的区别&lt;/h2&gt;&lt;p&gt;list：有序访问、索引访问，可以重复&lt;br&gt;set(HashSet、LinkedHashSet 或者 TreeSet)：去重&lt;br&gt;map：键值存储&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://uploadfiles.nowcoder.com/images/20200215/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://upload-images.jianshu.io/upload_images/5959612-31df64b17fb83cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1018/format/webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Java" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="集合" scheme="kaikaihit.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础|面向对象</title>
    <link href="kaikaihit.github.io/2020/08/27/Java-SE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>kaikaihit.github.io/2020/08/27/Java-SE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-08-27T08:37:20.000Z</published>
    <updated>2020-09-01T04:59:14.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="HashCode-方法和equals-方法有什么联系？"><a href="#HashCode-方法和equals-方法有什么联系？" class="headerlink" title="HashCode()方法和equals()方法有什么联系？"></a>HashCode()方法和equals()方法有什么联系？</h2><p>1.相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p><p>2.如果两个对象的hashCode相同，它们并不一定相同。</p><h2 id="构造函数、析构函数和函数的重载？"><a href="#构造函数、析构函数和函数的重载？" class="headerlink" title="构造函数、析构函数和函数的重载？"></a>构造函数、析构函数和函数的重载？</h2><p>构造函数：当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。</p><p>析构函数：当新对象结束生命周期时，系统自动调用。</p><p>函数的重载：函数的参数类型，参数个数不同。才能构成函数的重载。</p><p>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p><p>你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p><a id="more"></a><h2 id="方法重写overriding和方法重载overloading的区别"><a href="#方法重写overriding和方法重载overloading的区别" class="headerlink" title="方法重写overriding和方法重载overloading的区别"></a>方法重写overriding和方法重载overloading的区别</h2><p><strong>重写：</strong></p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p>1）参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p><p>2）返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p><p>3）访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p><p>4）重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p><p><img data-src="https://img-blog.csdnimg.cn/20200827165324423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="访问权限关键词"></p><p><strong>重载：</strong></p><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>1）必须具有不同的参数列表；</p><p>2）可以有不同的返回类型，只要参数列表不同就可以了；</p><p>3）可以有不同的访问修饰符；</p><p>4）可以抛出不同的异常；</p><h2 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h2><p>考察：接口</p><p>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。<br>② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题</p><h2 id="面向对象的“六原则一法则”"><a href="#面向对象的“六原则一法则”" class="headerlink" title="面向对象的“六原则一法则”"></a>面向对象的“六原则一法则”</h2><p>考察：Java对象</p><p>1.单一职责原则：一个类只做它该做的事情</p><p>2.依赖倒转原则：面向接口编程。</p><p>3.开闭原则：软件实体应当对扩展开放，对修改关闭。</p><p>4.里氏替换原则：任何时候都可以用子类型替换掉父类型。</p><p>5.接口隔离原则：接口要小而专，绝不能大而全。</p><p>6.合成聚合复用原则：优先使用聚合或合成关系复用代码。</p><p>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解</p><h2 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h2><p>1.抽象</p><p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只<br>是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p><p>2.继承</p><p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。但Java只支持单继承，即一个类只有一个父类。但Java的接口支持多继承，即一个子接口可以有多个父接口。</p><p>3.封装</p><p>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。</p><p>4.多态</p><p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享<br>、代码共享的优势，很好的解决了应用程序函数同名问题。</p><h2 id="Comparable和Comparator接口的作用以及它们的区别。"><a href="#Comparable和Comparator接口的作用以及它们的区别。" class="headerlink" title="Comparable和Comparator接口的作用以及它们的区别。"></a>Comparable和Comparator接口的作用以及它们的区别。</h2><p>Comparable提供了compareTo()方法，这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p><p>Comparatort提供了compare()和equals()两个方法。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</p><h2 id="extends和super泛型限定符"><a href="#extends和super泛型限定符" class="headerlink" title="extends和super泛型限定符"></a>extends和super泛型限定符</h2><p>泛型：参数化类型，定义方法时有形参，调用此方法时传递实参。</p><p>（1）泛型中上界和下界的定义</p><p>上界&lt;? extend Fruit&gt;</p><p>下界&lt;? super Apple&gt;</p><p>（2）上界和下界的特点</p><p>上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）</p><p>下界的list只能add，不能get</p><h2 id="类加载机制、双亲委派模型"><a href="#类加载机制、双亲委派模型" class="headerlink" title="类加载机制、双亲委派模型"></a>类加载机制、双亲委派模型</h2><p>类加载机制：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>双亲委派模型：</p><ol><li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li><li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。</li></ol><h2 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h2><p>StringBuffer线程安全，StringBuilder线程不安全，底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。</p><p>String：适用于少量的字符串操作。<br>StringBuilder：适用于单线程下在字符串缓冲区进行大量操作。<br>StringBuffer：适用于多线程下在字符串缓冲区进行大量操作。</p><h2 id="请说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#请说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h2><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><h2 id="请说明重载和重写的区别，相同参数不同返回值能重载吗？"><a href="#请说明重载和重写的区别，相同参数不同返回值能重载吗？" class="headerlink" title="请说明重载和重写的区别，相同参数不同返回值能重载吗？"></a>请说明重载和重写的区别，相同参数不同返回值能重载吗？</h2><p>重载(Overloading)</p><p>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。</p><p>重载Overloading是一个类中多态性的一种表现。</p><p>（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。</p><p>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</p><p>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</p><p>重写（Overriding）</p><p>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。</p><p>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。</p><p>方法重写又称方法覆盖。</p><p>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。</p><p>如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</p><p>（3）子类函数的访问修饰权限不能少于父类的。</p><h2 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h2><p>Object()默认构造方法。</p><p>clone() 创建并返回此对象的一个副本。</p><p>equals(Object obj) 指示某个其他对象是否与此对象“相等”。</p><p>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><p>getClass()返回一个对象的运行时类。</p><p>hashCode()返回该对象的哈希码值。</p><p>notify()唤醒在此对象监视器上等待的单个线程。 </p><p>notifyAll()唤醒在此对象监视器上等待的所有线程。</p><p>toString()返回该对象的字符串表示。</p><p>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p><p>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p><h2 id="wait方法和sleep-方法"><a href="#wait方法和sleep-方法" class="headerlink" title="wait方法和sleep()方法"></a>wait方法和sleep()方法</h2><p>1.<strong>wait()方法</strong>则是指当前线程让自己暂时退让出同步资源锁，<strong>sleep()方法</strong>正在执行的线程主动让出CPU。</p><p>2.<strong>sleep()方法</strong>可以在任何地方使用；<strong>wait()方法</strong>则只能在同步方法或同步块中使用</p><p>3.**sleep()**是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复.**wait()**是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RegExpTest.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;enter thread1 ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//释放锁有两种方式：(1)程序自然离开监视器的范围，即离开synchronized关键字管辖的代码范围</span></span><br><span class="line">                    <span class="comment">//(2)在synchronized关键字管辖的代码内部调用监视器对象的wait()方法。这里使用wait方法</span></span><br><span class="line">                    RegExpTest.class.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is going on ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is being over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//notify方法并不释放锁，即使thread2调用了下面的sleep方法休息10ms，但thread1仍然不会执行</span></span><br><span class="line">            <span class="comment">//因为thread2没有释放锁，所以Thread1得不到锁而无法执行</span></span><br><span class="line">            <span class="keyword">synchronized</span>(RegExpTest.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;enter thread2 ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 notify other thread can release wait status ...&quot;</span>);</span><br><span class="line">                RegExpTest.class.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is sleeping ten millisecond ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is going on ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is being over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200828105942972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;h2 id=&quot;HashCode-方法和equals-方法有什么联系？&quot;&gt;&lt;a href=&quot;#HashCode-方法和equals-方法有什么联系？&quot; class=&quot;headerlink&quot; title=&quot;HashCode()方法和equals()方法有什么联系？&quot;&gt;&lt;/a&gt;HashCode()方法和equals()方法有什么联系？&lt;/h2&gt;&lt;p&gt;1.相等（相同）的对象必须具有相等的哈希码（或者散列码）。&lt;/p&gt;
&lt;p&gt;2.如果两个对象的hashCode相同，它们并不一定相同。&lt;/p&gt;
&lt;h2 id=&quot;构造函数、析构函数和函数的重载？&quot;&gt;&lt;a href=&quot;#构造函数、析构函数和函数的重载？&quot; class=&quot;headerlink&quot; title=&quot;构造函数、析构函数和函数的重载？&quot;&gt;&lt;/a&gt;构造函数、析构函数和函数的重载？&lt;/h2&gt;&lt;p&gt;构造函数：当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。&lt;/p&gt;
&lt;p&gt;析构函数：当新对象结束生命周期时，系统自动调用。&lt;/p&gt;
&lt;p&gt;函数的重载：函数的参数类型，参数个数不同。才能构成函数的重载。&lt;/p&gt;
&lt;p&gt;Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。&lt;/p&gt;
&lt;p&gt;你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试宝典" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
    <category term="Java" scheme="kaikaihit.github.io/categories/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java/"/>
    
    
    <category term="Java" scheme="kaikaihit.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="kaikaihit.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
