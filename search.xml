<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java EE基础|Struts</title>
    <url>/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Struts/</url>
    <content><![CDATA[<h2 id="STRUTS的应用场景"><a href="#STRUTS的应用场景" class="headerlink" title="STRUTS的应用场景"></a>STRUTS的应用场景</h2><p>Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。采用Struts开发出基于MVC（Model、View和Controller）设计模式的应用架构。有如下功能：</p>
<p>包含一个controller servlet，能将用户的请求发送到相应的Action对象。</p>
<p>JSP自由Tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。</p>
<p>提供一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Struts</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM简介</title>
    <url>/2020/08/17/BOM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>BOM（Bill of Material）物料清单，也就是以数据格式来描述产品结构的文件，是计算机可以识别的产品结构数据文件，也是ERP的主导文件。BOM使系统识别产品结构，也是联系与沟通企业各项业务的纽带。</p>
<p>物料清单(BOM)是指生产或组装最小批量的某个产品所需物料的需求清单，包含物料、单位用量、损耗率等信息，其中最小批量没有指明默认值就是数量1。</p>
<p>物料清单(BOM)也是计算生产一批产品所需物料的毛需求的前置基础资料,单位用量乘以生产数量就是所需某个物料的毛需求数量。</p>
<p>物料清单(BOM)也是接单时核算产品预估成本的重要依据,单项物料成本用单位用量乘以市场购买价得到，然后累计各单项物料成本，就是生产一个产品的材料成本。</p>
<a id="more"></a>

<p><strong>成套设备</strong>：在生产企业一般不用装配工序连接，但用于完成相互联系的使用功能的两个或两个以上的产品的总和；</p>
<p><strong>零件</strong>：不采用装配工序制成的单一成品；</p>
<p><strong>部件</strong>：由若干个部分（零件、分部件），以可拆成或不可拆的形式组成的成品；分部件可以按照其从属产品关系划分为1级分部件，2级分部件。</p>
<p><strong>总成</strong>：能够执行一定独立功能的由若干个部门以可拆成或不可拆的形式组成的复杂成品，例如发动机总成，车桥总成，前轴总成等；由零件和部件组成；也可能叫组件、整件、装置、全件等说法。复杂产品可能还有分总成。</p>
<p><strong>模块</strong>：具有相对独立功能和通用接口的单元。类似总成，但可能比较简单。</p>
<p><strong>专用件（基本件）</strong>：本产品专用的零部件。不过在实际中往往借用关系比较多，专用件的实际含义是首次应用在本产品上的零部件。</p>
<p><strong>借用件</strong>：在本产品中采用已有产品的组成部分，这些组成部分叫借用件。</p>
<p><strong>通用件</strong>：在不同类型或同类型不同规格的产品中具有互换性的零部件。</p>
<p><strong>标准件</strong>：经过优选、简化、统一并给予标准代号的零部件。</p>
<p><strong>替换件</strong>：本产品必须要有的组成部分，一般数量都不变化，例如汽车的发动机。可以有多种选装规格。</p>
<p><strong>选装件</strong>：本产品不一定要有的组成部分，可以有多个选装规格。</p>
<h5 id="为了便于计算机识别，必须把用图示表达的产品结构转化成某种数据格式，这种以数据格式来描述产品结构的文件就是物料清单，即是BOM（产品结构表或产品结构树，配方表和要素表），定义产品的技术文件。"><a href="#为了便于计算机识别，必须把用图示表达的产品结构转化成某种数据格式，这种以数据格式来描述产品结构的文件就是物料清单，即是BOM（产品结构表或产品结构树，配方表和要素表），定义产品的技术文件。" class="headerlink" title="为了便于计算机识别，必须把用图示表达的产品结构转化成某种数据格式，这种以数据格式来描述产品结构的文件就是物料清单，即是BOM（产品结构表或产品结构树，配方表和要素表），定义产品的技术文件。"></a>为了便于计算机识别，必须把用图示表达的产品结构转化成某种数据格式，这种以数据格式来描述产品结构的文件就是物料清单，即是BOM（产品结构表或产品结构树，配方表和要素表），定义产品的技术文件。</h5><p><img data-src="https://img-blog.csdnimg.cn/20200817112853508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200817112906774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>参考：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//www.zhihu.<span class="keyword">com</span>/<span class="built_in">search</span>?<span class="built_in">type</span>=content&amp;q=BOM</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工业机理模型</category>
      </categories>
      <tags>
        <tag>BOM</tag>
        <tag>知识图谱</tag>
        <tag>工业机理模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE基础|Hibernate</title>
    <url>/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Hibernate/</url>
    <content><![CDATA[<h2 id="实体对象的三种形式以及转换关系"><a href="#实体对象的三种形式以及转换关系" class="headerlink" title="实体对象的三种形式以及转换关系"></a>实体对象的三种形式以及转换关系</h2><p>瞬时态、持久态、游状态</p>
<p>瞬时态：new一个对象，这个对象处于瞬时态。</p>
<p>持久态：实例在数据库中有对应的记录。Session进行了Save、saveOrUpdate()、persist()、merge()方法把瞬时态转成持久态。</p>
<p>游离态：对象不在持久化管理之内，所以处于游离态。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。Session进行了close()、clear()、evict()或flush()后，由持久态变成游离态。</p>
<h2 id="锁的机制的作用"><a href="#锁的机制的作用" class="headerlink" title="锁的机制的作用"></a>锁的机制的作用</h2><p>有些业务逻辑在执行过程中要求对数据进行排他性的访问，需要通过一些机制保证在此过程中数据被锁住不会被外接修改，这就是锁机制。</p>
<p>Hibernate支持悲观锁和乐观锁两种锁机制。</p>
<p>悲观锁，在数据处理过程中极有可能存在修改数据的并发事务，于是将处理的数据设置为锁定状态。</p>
<p>乐观锁，对并发事务持乐观态度，通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响</p>
<p>Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE基础|Spring</title>
    <url>/2020/08/30/Java-EE%E5%9F%BA%E7%A1%80-Spring/</url>
    <content><![CDATA[<h2 id="Spring的自动装配"><a href="#Spring的自动装配" class="headerlink" title="Spring的自动装配"></a>Spring的自动装配</h2><p>- no：不进行自动装配，手动设置Bean的依赖关系。<br>- byName：根据Bean的名字进行自动装配。<br>- byType：根据Bean的类型进行自动装配。<br>- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。<br>- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p>
<a id="more"></a>

<h2 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h2><p>Spring2.X针对WebApplicationContext新增了3个作用域。分别是request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p>
<h2 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h2><p><strong>IOC控制反转</strong></p>
<p>Inversion of Control。控制反转是把传统上由程序代码直接操作的对象交给容器，通过容器来实现对象组件的装配和管理。控制反转就是对组件对象控制权的转移，从程序代码本身转移到外部容器，由容器来创建对象并管理对象之间的依赖关系。</p>
<p><strong>DI依赖注入</strong></p>
<p>Dependency Injection。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由<strong>容器负责</strong></p>
<h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><p><strong>BeanFactory：</strong></p>
<p>是spring比较原始的Factory。无法支持spring插件，例如AOP、Web等功能。</p>
<p>多用于移动设备的开发。</p>
<p><strong>ApplicationContext：</strong></p>
<p>是BeanFactory的子接口，因为古老的BeanFactory无法满足不断更新的spring需求，于是ApplicationContext就代替了BeanFactory的工作。</p>
<h2 id="springIOC原理"><a href="#springIOC原理" class="headerlink" title="springIOC原理"></a>springIOC原理</h2><p>IOC控制反转：是spring的核心，贯穿始终，对于spring框架来说，由spring负责控制对象的生命周期和对象间的关系。</p>
<p>实现IOC的步骤：</p>
<p>定义用来描述bean的配置的Java类</p>
<p>解析bean的配置，将bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术。</p>
<p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java反射机制实例化对象，将实例化的对象保存在另外一个Map中即可。</p>
<h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><p>1.Set注入</p>
<p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）。</p>
<p>2.构造器注入</p>
<p>通过将@Autowired注解放在构造器上来完成构造器注入，默认构造器参数通过类型自动装配</p>
<p>3.接口注入</p>
<h2 id="autowired-和resource区别"><a href="#autowired-和resource区别" class="headerlink" title="autowired 和resource区别"></a>autowired 和resource区别</h2><p>共同点：都可以写在字段和setter方法上。两者如果都写在字段上，就不需要再写setter方法。</p>
<p>不同点：</p>
<p><strong>@Autowired</strong></p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<p>@Autowired注解是<strong>按照类型（byType）装配依赖对象</strong>，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p>
<p><strong>@Resource</strong></p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>创建，准备，使用，销毁</p>
<p><img data-src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt="img"></p>
<p><img data-src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt="img"></p>
<h2 id="IOC和AOP是什么"><a href="#IOC和AOP是什么" class="headerlink" title="IOC和AOP是什么"></a>IOC和AOP是什么</h2><p><strong>IOC</strong>是控制反转，与依赖注入DI是一个概念。依赖注入的三种方式：接口注入、构造器注入和Setter注入</p>
<p>IOC的目的：</p>
<p>​    （1）脱开、降低类之间的耦合；</p>
<p>​    （2）倡导面向接口编程、实施依赖倒换原则； </p>
<p>​    （3）提高系统可插入、可测试、可修改等特性。</p>
<p><strong>AOP</strong>是面向切面编程：</p>
<p>​    传统的方式是OOP。Object Oriented Programming面向对象编程，引入封装、继承和多态。允许开发者定义纵向的关系，但是会使很多代码重复，不利于各个模块的重用。</p>
<h2 id="Spring支持的事务管理"><a href="#Spring支持的事务管理" class="headerlink" title="Spring支持的事务管理"></a>Spring支持的事务管理</h2><p>Spring支持编程式事务管理和声明式事务管理</p>
<p>事务分为全局事务和局部事务。</p>
<p><strong>全局事务由应用服务器管理</strong>，需要底层服务器JTA支持（如WebLogic、WildFly等）。</p>
<p>局部事务和底层采用的持久化方案有关，例如：使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p>
<h2 id="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）"><a href="#AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）" class="headerlink" title="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）"></a>AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）</h2><p>AOP，指面向切面编程。作为面向对象的一种不愁，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等。实现的关键在于AOP框架自动创建的AOP代理，AOP代理分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。</p>
<p>连接点：程序执行的某个特定位置。</p>
<p>切点：一个切点可以匹配多个连接点</p>
<p>增强：增强是织入到目标类连接点上的一段程序代码</p>
<p>引介：是一种特殊的增强。</p>
<p>织入：将增强添加到目标类具体连接点上的过程。编译器织入、装载器织入和运行时织入。</p>
<p>切面：切面由切点和增强（引介）组成的。包括了对横切关注功能的定义，也包括了对连接点的定义。</p>
<h2 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h2><p>Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。</p>
<h2 id="Spring框架为企业级开发带来的好处"><a href="#Spring框架为企业级开发带来的好处" class="headerlink" title="Spring框架为企业级开发带来的好处"></a>Spring框架为企业级开发带来的好处</h2><p>非侵入式：支持基于POJO（不继承其它类，也不实现其它接口的Java基础类）的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。</p>
<p>IOC控制反转</p>
<p>AOP面向切面编程</p>
<p>MVC框架，为Web表示层提供更好的解决方案。</p>
<p>事物管理：Spring以宽广的胸怀接纳多种持久化技术，并为其提供了声明式的实务管理，在不需要任何代码的情况下就能完成事务管理。</p>
<h2 id="Struts拦截器和Spring-AOP有什么区别"><a href="#Struts拦截器和Spring-AOP有什么区别" class="headerlink" title="Struts拦截器和Spring AOP有什么区别"></a>Struts拦截器和Spring AOP有什么区别</h2><p>拦截器是AOP的一种实现，struts2 拦截器采用xwork2的interceptor。而spring的AOP基于IoC基础,其底层采用动态代理与CGLIB代理两种方式结合的实现方式</p>
<h2 id="简单介绍一下Spring"><a href="#简单介绍一下Spring" class="headerlink" title="简单介绍一下Spring"></a>简单介绍一下Spring</h2><p>Spring是一个轻量级框架，可以一站式构建你的企业级应用。</p>
<p>Spring的模块大概分为6个。分别是：</p>
<p>1、Core Container（Spring的核心）【重要】</p>
<p>2、AOP（面向切面变成）【重要】</p>
<p>3、Messaging（消息发送的支持）</p>
<p>4、Data Access/Integration（数据访问和集成）</p>
<p>5、Web（主要是SpringWeb内容，包括MVC）【重要】</p>
<p>6、Test（Spring测试支持，包含JUint等测试单元的支持） </p>
<p>7、Instrumentation（设备支持，比如Tomcat的支持）</p>
<h2 id="持久层要考虑的问题有哪些，有哪些持久层框架"><a href="#持久层要考虑的问题有哪些，有哪些持久层框架" class="headerlink" title="持久层要考虑的问题有哪些，有哪些持久层框架"></a>持久层要考虑的问题有哪些，有哪些持久层框架</h2><p><strong>持久层设计的目标包括：</strong><br>- 数据存储逻辑的分离，提供抽象化的数据访问接口。<br>- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。<br>- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。<br>- 数据抽象，提供更面向对象的数据操作。</p>
<p><strong>持久层框架有：</strong><br>- Hibernate<br>- MyBatis<br>- TopLink<br>- Guzz<br>- jOOQ<br>- Spring Data<br>- ActiveJDBC</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|GC</title>
    <url>/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-GC/</url>
    <content><![CDATA[<h2 id="垃圾回收的优点以及原理。"><a href="#垃圾回收的优点以及原理。" class="headerlink" title="垃圾回收的优点以及原理。"></a>垃圾回收的优点以及原理。</h2><p><strong>优点：</strong></p>
<p>1.java中的重大特点就是引用了垃圾回收机制，使得java程序员在编写程序的时候不用考虑内存管理。</p>
<p>2.有垃圾回收机制，java中的对象不再有“作用域的概念，只有对象的引用才有”作用域“。</p>
<p>3.垃圾回收机制有效的防止内存泄露，有效的使用可以使用的内存。</p>
<p><strong>工作原理：</strong></p>
<p>当创建对象时，GC就开始监视这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理heap（堆）中的素有对象。通过这种方式确定哪些对象时“可达的”，哪些是“不可达的”。</p>
<p>垃圾回收机制通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清理，我们虽然可以调用System.gc()让垃圾回收器运行，但依旧无法保证GC一定会执行。</p>
<p>GC，Gabage Collection，可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
<h2 id="JVM怎么确定哪些对象应该进行回收？"><a href="#JVM怎么确定哪些对象应该进行回收？" class="headerlink" title="JVM怎么确定哪些对象应该进行回收？"></a>JVM怎么确定哪些对象应该进行回收？</h2><p>JVM 的垃圾回收器主要关注的是堆上创建的实例对象，在每次对这些对象进行回收前，需要确定哪些对象是可以去进行回收的。主要由下面两种方法。</p>
<p><strong>1.引用计数算法</strong></p>
<p>给对象添加一个引用计数器，当有一个地方引用它，计数器值加1；当引用失效时，计数器值减1。任何时候计数器值为0表示这个对象可以被回收了。</p>
<p>优点：</p>
<p>判断效率高，实现简单。</p>
<p>缺点：</p>
<p>难以解决对象之间相互循序引用的问题。</p>
<p><strong>2.可达性分析算法</strong></p>
<p>可作为GC Roots的对象有：</p>
<ol>
<li>虚拟机栈中的引用的对象</li>
<li>方法区的静态变量和常量引用的对象</li>
<li>本地方法栈中JNI引用的对象。</li>
</ol>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|IO和NIOAIO</title>
    <url>/2020/08/29/Java-SE%E5%9F%BA%E7%A1%80-IO%E5%92%8CNIOAIO/</url>
    <content><![CDATA[<h2 id="JAVA中有几种类型的流"><a href="#JAVA中有几种类型的流" class="headerlink" title="JAVA中有几种类型的流"></a>JAVA中有几种类型的流</h2><p>字节流，字符流</p>
<p>字节流继承于InputStream和OutputStream</p>
<p>字符流继承于InputStreamReader和OutputStreamWriter.</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|线程</title>
    <url>/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程的基本状态以及状态之间的关系"><a href="#线程的基本状态以及状态之间的关系" class="headerlink" title="线程的基本状态以及状态之间的关系"></a>线程的基本状态以及状态之间的关系</h2><p>运行态：Running</p>
<p>就绪态：Runnable，万事俱备，只欠CPU</p>
<p>阻塞状态：Blocked。调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
<h2 id="进程、线程和协程的区别"><a href="#进程、线程和协程的区别" class="headerlink" title="进程、线程和协程的区别"></a>进程、线程和协程的区别</h2><p>进程是系统进行资源分配和调用的基本单位，每一个进程都有它自己的内存空间和系统资源。</p>
<p>线程是进程的执行单位或者执行路线，进程也是CPU调度的基本单位。</p>
<p>协程是用户态的轻量级线程。</p>
<p>先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题<br>多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大<br>多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行<br>协程以后主要用在网络爬虫和网络请求，开辟一个协程大概需要5k空间，开辟一个线程需要512k空间， 开辟一个进程占用资源最多</p>
<h2 id="举例说明同步和异步"><a href="#举例说明同步和异步" class="headerlink" title="举例说明同步和异步"></a>举例说明同步和异步</h2><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p>
<h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争</p>
<h2 id="线程从创建到死亡的几种状态都有哪些"><a href="#线程从创建到死亡的几种状态都有哪些" class="headerlink" title="线程从创建到死亡的几种状态都有哪些"></a>线程从创建到死亡的几种状态都有哪些</h2><p><img data-src="https://uploadfiles.nowcoder.com/images/20190908/93694598_1567901669525_2E1604194BEFDDB0EE43167B50B364AB" alt="img"></p>
<h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。</p>
<p>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h2 id="AQS的理解"><a href="#AQS的理解" class="headerlink" title="AQS的理解"></a>AQS的理解</h2><p>AbstractQueuedSynchronizer简称AQS。是实现锁的框架。</p>
<p>实现的关键是：先进先出的队列、state状态。</p>
<h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>支持并发、解耦</p>
<p>生产者消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Java线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|JVM</title>
    <url>/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-JVM/</url>
    <content><![CDATA[<h2 id="JVM加载class文件的原理"><a href="#JVM加载class文件的原理" class="headerlink" title="JVM加载class文件的原理"></a>JVM加载class文件的原理</h2><p>JVM中类的装载是由ClassLoader和它的子类来实现的，Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<p>类装载方式，有两种。</p>
<p>隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。</p>
<p>显示装载：通过class.forname()等方法，显示加载需要的类，隐式加载与显式加载的区别：两者本质是一样的。</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>可执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p>
<p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者重写编译。Java虚拟机让这个变为可能。</p>
<p>（1）堆内存分配</p>
<p>JVM初始内存由-Xms指定，默认是物理内存的1/64；JVM最大分配内存由-Xms指定，默认是物理内存的1/4。默认空余堆内存小 于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC后调整堆的大小</p>
<p>（2）非堆内存分配</p>
<p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p>
<p>（3）VM最大内存</p>
<p>JVM内存限制于实际的最大物理内存，结社物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。32位处理器虽然可控内存空间有4GB。但是具体的操作系统会给一个限制，这个限制一般是2GB~3GB（一般来说Windows系统下为1.5G-2G，Linux系 统下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<p>（4）几个不同公司不同版本JVM最大堆内存</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180926/308572_1537966762062_914FBB519FF1ACBAF602B2DCBD5184D6" alt="img"></p>
<h2 id="哪些可作为Root对象"><a href="#哪些可作为Root对象" class="headerlink" title="哪些可作为Root对象"></a>哪些可作为Root对象</h2><p>\1. 虚拟机栈中的引用对象<br>\2. 本地方法栈中JNI引用对象<br>\3. 方法区中类静态属性引用的对象<br>\4. 方法区中常量引用对象（如字符串常量池）<br>\5. 被同步锁持有的对象<br>\6. 内部引用（如基本数据类型对应的class对象、常驻的异常对象NullPointerException等、系统类加载器）</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|集合</title>
    <url>/2020/08/28/Java-SE%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="List、Map、Set的区别"><a href="#List、Map、Set的区别" class="headerlink" title="List、Map、Set的区别"></a>List、Map、Set的区别</h2><p>list：有序访问、索引访问，可以重复<br>set(HashSet、LinkedHashSet 或者 TreeSet)：去重<br>map：键值存储</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20200215/1034884_1581738199162_50125D538C24748FCB1032CB38EEE0A9" alt="img"></p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/5959612-31df64b17fb83cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1018/format/webp" alt="img"></p>
<a id="more"></a>

<p>List：</p>
<blockquote>
<p>1.可以允许重复的对象。<br>2.可以插入多个null元素。<br>3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。<br>4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p>
</blockquote>
<p>Set：</p>
<blockquote>
<p>1 .不允许重复对象</p>
<p>2.无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</p>
<p>3.只允许一个 null 元素</p>
<p>4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p>
</blockquote>
<p><img data-src="https://upload-images.jianshu.io/upload_images/5959612-bb4adde83f977ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/660/format/webp" alt="img"></p>
<p>Map：</p>
<blockquote>
<p>1.Map不是collection的子接口或者实现类。Map是一个接口。</p>
<p>2.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p>
<p>3.TreeMap 也通过 Comparator  或者 Comparable 维护了一个排序顺序。</p>
<p>4.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p>
<p>5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p>
</blockquote>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。</p>
<h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别</h2><p>Iterator的安全失败是基于对底层集合做拷贝，它不受源集合上修改的影响。</p>
<p>java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的</p>
<p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h2 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h2><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：<strong>增加元素，替换元素，获取前一个和后一个元素的索引</strong>，等等。</p>
<h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口。</p>
<p>Java集合类框架的基本接口有哪些？</p>
<p>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>
<h2 id="TreeMap的底层实现"><a href="#TreeMap的底层实现" class="headerlink" title="TreeMap的底层实现"></a>TreeMap的底层实现</h2><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p>
<p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。</p>
<p>红黑树性质：</p>
<p>性质1：每个节点要么是红色，要么是黑色。</p>
<p>性质2：根节点永远是黑色的。</p>
<p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>
<p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>
<p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。</p>
<p>性质1：每个节点要么是黑色，要么是红色。</p>
<p>性质2：根节点是黑色。</p>
<p>性质3：每个叶子节点（NIL）是黑色。</p>
<p>性质4：每个红色结点的两个子结点一定都是黑色。</p>
<p><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></p>
<p>三种操作：左旋、右旋和变色。</p>
<ul>
<li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li>
<li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li>
<li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li>
</ul>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|面向对象</title>
    <url>/2020/08/27/Java-SE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="HashCode-方法和equals-方法有什么联系？"><a href="#HashCode-方法和equals-方法有什么联系？" class="headerlink" title="HashCode()方法和equals()方法有什么联系？"></a>HashCode()方法和equals()方法有什么联系？</h2><p>1.相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p>
<p>2.如果两个对象的hashCode相同，它们并不一定相同。</p>
<h2 id="构造函数、析构函数和函数的重载？"><a href="#构造函数、析构函数和函数的重载？" class="headerlink" title="构造函数、析构函数和函数的重载？"></a>构造函数、析构函数和函数的重载？</h2><p>构造函数：当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。</p>
<p>析构函数：当新对象结束生命周期时，系统自动调用。</p>
<p>函数的重载：函数的参数类型，参数个数不同。才能构成函数的重载。</p>
<p>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p>
<p>你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p>
<a id="more"></a>

<h2 id="方法重写overriding和方法重载overloading的区别"><a href="#方法重写overriding和方法重载overloading的区别" class="headerlink" title="方法重写overriding和方法重载overloading的区别"></a>方法重写overriding和方法重载overloading的区别</h2><p><strong>重写：</strong></p>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
<p>1）参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>2）返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p>
<p>3）访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>4）重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200827165324423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="访问权限关键词"></p>
<p><strong>重载：</strong></p>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>1）必须具有不同的参数列表；</p>
<p>2）可以有不同的返回类型，只要参数列表不同就可以了；</p>
<p>3）可以有不同的访问修饰符；</p>
<p>4）可以抛出不同的异常；</p>
<h2 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h2><p>考察：接口</p>
<p>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。<br>② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题</p>
<h2 id="面向对象的“六原则一法则”"><a href="#面向对象的“六原则一法则”" class="headerlink" title="面向对象的“六原则一法则”"></a>面向对象的“六原则一法则”</h2><p>考察：Java对象</p>
<p>1.单一职责原则：一个类只做它该做的事情</p>
<p>2.依赖倒转原则：面向接口编程。</p>
<p>3.开闭原则：软件实体应当对扩展开放，对修改关闭。</p>
<p>4.里氏替换原则：任何时候都可以用子类型替换掉父类型。</p>
<p>5.接口隔离原则：接口要小而专，绝不能大而全。</p>
<p>6.合成聚合复用原则：优先使用聚合或合成关系复用代码。</p>
<p>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解</p>
<h2 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h2><p>1.抽象</p>
<p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只<br>是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p>2.继承</p>
<p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。但Java只支持单继承，即一个类只有一个父类。但Java的接口支持多继承，即一个子接口可以有多个父接口。</p>
<p>3.封装</p>
<p>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。</p>
<p>4.多态</p>
<p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享<br>、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<h2 id="Comparable和Comparator接口的作用以及它们的区别。"><a href="#Comparable和Comparator接口的作用以及它们的区别。" class="headerlink" title="Comparable和Comparator接口的作用以及它们的区别。"></a>Comparable和Comparator接口的作用以及它们的区别。</h2><p>Comparable提供了compareTo()方法，这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p>
<p>Comparatort提供了compare()和equals()两个方法。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。</p>
<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</p>
<h2 id="extends和super泛型限定符"><a href="#extends和super泛型限定符" class="headerlink" title="extends和super泛型限定符"></a>extends和super泛型限定符</h2><p>泛型：参数化类型，定义方法时有形参，调用此方法时传递实参。</p>
<p>（1）泛型中上界和下界的定义</p>
<p>上界&lt;? extend Fruit&gt;</p>
<p>下界&lt;? super Apple&gt;</p>
<p>（2）上界和下界的特点</p>
<p>上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）</p>
<p>下界的list只能add，不能get</p>
<h2 id="类加载机制、双亲委派模型"><a href="#类加载机制、双亲委派模型" class="headerlink" title="类加载机制、双亲委派模型"></a>类加载机制、双亲委派模型</h2><p>类加载机制：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>双亲委派模型：</p>
<ol>
<li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li>
<li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。</li>
</ol>
<h2 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h2><p>StringBuffer线程安全，StringBuilder线程不安全，底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。</p>
<p>String：适用于少量的字符串操作。<br>StringBuilder：适用于单线程下在字符串缓冲区进行大量操作。<br>StringBuffer：适用于多线程下在字符串缓冲区进行大量操作。</p>
<h2 id="请说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#请说明”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h2><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<h2 id="请说明重载和重写的区别，相同参数不同返回值能重载吗？"><a href="#请说明重载和重写的区别，相同参数不同返回值能重载吗？" class="headerlink" title="请说明重载和重写的区别，相同参数不同返回值能重载吗？"></a>请说明重载和重写的区别，相同参数不同返回值能重载吗？</h2><p>重载(Overloading)</p>
<p>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。</p>
<p>重载Overloading是一个类中多态性的一种表现。</p>
<p>（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。</p>
<p>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</p>
<p>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</p>
<p>重写（Overriding）</p>
<p>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。</p>
<p>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。</p>
<p>方法重写又称方法覆盖。</p>
<p>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。</p>
<p>如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</p>
<p>（3）子类函数的访问修饰权限不能少于父类的。</p>
<h2 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h2><p>Object()默认构造方法。</p>
<p>clone() 创建并返回此对象的一个副本。</p>
<p>equals(Object obj) 指示某个其他对象是否与此对象“相等”。</p>
<p>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<p>getClass()返回一个对象的运行时类。</p>
<p>hashCode()返回该对象的哈希码值。</p>
<p>notify()唤醒在此对象监视器上等待的单个线程。 </p>
<p>notifyAll()唤醒在此对象监视器上等待的所有线程。</p>
<p>toString()返回该对象的字符串表示。</p>
<p>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<p>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<h2 id="wait方法和sleep-方法"><a href="#wait方法和sleep-方法" class="headerlink" title="wait方法和sleep()方法"></a>wait方法和sleep()方法</h2><p>1.<strong>wait()方法</strong>则是指当前线程让自己暂时退让出同步资源锁，<strong>sleep()方法</strong>正在执行的线程主动让出CPU。</p>
<p>2.<strong>sleep()方法</strong>可以在任何地方使用；<strong>wait()方法</strong>则只能在同步方法或同步块中使用</p>
<p>3.**sleep()**是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复.**wait()**是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RegExpTest.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;enter thread1 ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//释放锁有两种方式：(1)程序自然离开监视器的范围，即离开synchronized关键字管辖的代码范围</span></span><br><span class="line">                    <span class="comment">//(2)在synchronized关键字管辖的代码内部调用监视器对象的wait()方法。这里使用wait方法</span></span><br><span class="line">                    RegExpTest.class.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is going on ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 is being over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//notify方法并不释放锁，即使thread2调用了下面的sleep方法休息10ms，但thread1仍然不会执行</span></span><br><span class="line">            <span class="comment">//因为thread2没有释放锁，所以Thread1得不到锁而无法执行</span></span><br><span class="line">            <span class="keyword">synchronized</span>(RegExpTest.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;enter thread2 ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 notify other thread can release wait status ...&quot;</span>);</span><br><span class="line">                RegExpTest.class.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is sleeping ten millisecond ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is going on ...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is being over!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20200828105942972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web基础</title>
    <url>/2020/08/30/Java-Web%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="JAVA应用服务器"><a href="#JAVA应用服务器" class="headerlink" title="JAVA应用服务器"></a>JAVA应用服务器</h2><p>BEA WebLogic Server，</p>
<p>IBM WebSphere Application Server，</p>
<p>Oracle9i Application Server</p>
<p>jBoss，</p>
<p>Tomcat</p>
<a id="more"></a>

<h2 id="Assert断言"><a href="#Assert断言" class="headerlink" title="Assert断言"></a>Assert断言</h2><p>常见的调试方式，很多开发语言支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<h2 id="1分钟之内只能处理1000个请求，怎么实现？"><a href="#1分钟之内只能处理1000个请求，怎么实现？" class="headerlink" title="1分钟之内只能处理1000个请求，怎么实现？"></a>1分钟之内只能处理1000个请求，怎么实现？</h2><p>实现方法：计数器、滑动窗口、漏桶法和令牌桶</p>
<p>a) 对所有用户访问的次数计数。 定义一个计时器，单位为一分钟。 如果超出次数，就拒绝该请求。 一分钟后， 次数刷新值为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在单位计数中判断List中数量是否超出限制即可。</p>
<p>b) 使用aop实现请求的限制， 在需要限制的请求方法上加上aop逻辑。</p>
<h2 id="JSP中的静态包含和动态包含的有哪些区别"><a href="#JSP中的静态包含和动态包含的有哪些区别" class="headerlink" title="JSP中的静态包含和动态包含的有哪些区别"></a>JSP中的静态包含和动态包含的有哪些区别</h2><p>静态包含是通过JSP的include指令包含页面。</p>
<p>动态包含是通过JSP标准动作<a href="jsp:forward">jsp:forward</a>包含页面</p>
<p>&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file=”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page=”…”&gt;<br>&lt;jsp:param name=”…” value=”…” /&gt;<br></jsp:include></p>
<h2 id="表达式语言（EL）的隐式对象以及该对象的作用"><a href="#表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="表达式语言（EL）的隐式对象以及该对象的作用"></a>表达式语言（EL）的隐式对象以及该对象的作用</h2><p>EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）</p>
<h2 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h2><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p>
<h2 id="web-xml文件"><a href="#web-xml文件" class="headerlink" title="web.xml文件"></a>web.xml文件</h2><p>web.xml用于配置Web应用的相关信息</p>
<p>监听器、过滤器、Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。</p>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。<br>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。<br>③HttpSessionListener：对Session的创建和销毁进行监听。</p>
<p>④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。<br>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。<br>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p>
<p>Session销毁：</p>
<p>1.session超时，从web.xml文件中通过<session-config>/<session-timeout>标签配置超时时间。</p>
<p>2.通过调用session对象的invalidate()方法使session失效。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。</p>
<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<p>Servlet 通过调用 init () 方法进行初始化。</p>
<p>Servlet 调用 service() 方法来处理客户端的请求。</p>
<p>Servlet 通过调用 destroy() 方法终止（结束）。</p>
<p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>
<p>Servlet单实例，减少了产生servlet的开销；</p>
<h2 id="（转发）forward与（重定向）redirect区别"><a href="#（转发）forward与（重定向）redirect区别" class="headerlink" title="（转发）forward与（重定向）redirect区别"></a>（转发）forward与（重定向）redirect区别</h2><p>forward是转发，redirect是重定向</p>
<p><strong>1.地址栏显示不同</strong></p>
<p>forward是服务器请求，地址栏还是原来的地址</p>
<p>redirect是服务端根据逻辑，发送一个状态码，地址栏显示的是新的URL</p>
<p><strong>2.数据共享不同</strong></p>
<p>forward，转发页面和转发到的页面可以共享request里面的数据。</p>
<p>redirect，不能共享数据。</p>
<p><strong>3.运用场景不同</strong></p>
<p>forward：用于用户登录，根据角色转发到相应的模块。</p>
<p>redirect：用于用户注销登录时返回主页面和跳转到其它的网站等。</p>
<p><strong>4.效率不同</strong></p>
<p>forward：高</p>
<p>redirect：低</p>
<p>redirect的状态码是302</p>
<h2 id="redis的List能在什么场景下使用"><a href="#redis的List能在什么场景下使用" class="headerlink" title="redis的List能在什么场景下使用"></a>redis的List能在什么场景下使用</h2><p>Redis中的list的数据结构是双向链表，可以非常便捷的应用于消息队列（生产者/消费者模型）。消息的生产者只需要通过ipush将消息放入list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。</p>
<h2 id="AOF和RDB"><a href="#AOF和RDB" class="headerlink" title="AOF和RDB"></a>AOF和RDB</h2><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p>
<p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来存放。</p>
<h2 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h2><p>1.减少对数据库的读操作，数据库压力降低。</p>
<p>2.加快了响应速度。</p>
<h2 id="redis-读写速率快、性能好"><a href="#redis-读写速率快、性能好" class="headerlink" title="redis 读写速率快、性能好"></a>redis 读写速率快、性能好</h2><p>Redis是纯内存数据库，相对于读写磁盘，Hash查找可以达到每秒百万次的数量级。</p>
<h2 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h2><p>第一阶段：与master建立连接</p>
<p>第二阶段：向master发起同步请求（SYNC）</p>
<p>第三阶段：接受master发来的RDB数据</p>
<p>第四阶段：载入RDB文件</p>
<h2 id="DAO模式"><a href="#DAO模式" class="headerlink" title="DAO模式"></a>DAO模式</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。</p>
<p>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象）。前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h2 id="MVC各个部分需要的技术"><a href="#MVC各个部分需要的技术" class="headerlink" title="MVC各个部分需要的技术"></a>MVC各个部分需要的技术</h2><p>Model-View-Controller</p>
<p>Model：实现系统中的业务逻辑</p>
<p>View：用于与用户的交互。</p>
<p>Controller：是model与View之间沟通的桥梁。提供应用的处理过程。</p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>1.get请求用来从服务器上获得资源，而post用来向服务器提交数据。</p>
<p>2.get时参数会显示在地址栏上，post的地址栏不会显示。</p>
<p>3.get传输收到url的限制，1024字节；而post可以传输大量的数据，上传文件通常使用post方式。</p>
<h2 id="J2EE中常用的名词进行解释"><a href="#J2EE中常用的名词进行解释" class="headerlink" title="J2EE中常用的名词进行解释"></a>J2EE中常用的名词进行解释</h2><p><strong>web 容器：</strong>给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题</p>
<p><strong>Web container：</strong>实现J2EE体系结构中Web组件协议的容器。</p>
<p><strong>EJB容器：</strong>Enterprise java bean 容器。更具有行业领域特色。</p>
<p><strong>JNDI：</strong>（Java Naming &amp; Directory Interface）JAVA命名目录服务</p>
<p><strong>JMS：</strong>（Java Message Service）JAVA消息服务</p>
<p><strong>JTA：</strong>（Java Transaction API）JAVA事务服务</p>
<p><strong>JAF：</strong>（Java Action FrameWork）JAVA安全认证框架</p>
<p><strong>RMI/IIOP:</strong> （Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务</p>
<h2 id="网站在架构上应当考虑哪些问题"><a href="#网站在架构上应当考虑哪些问题" class="headerlink" title="网站在架构上应当考虑哪些问题"></a>网站在架构上应当考虑哪些问题</h2><p><strong>1.分层</strong></p>
<p>分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统</p>
<p><strong>2.分割</strong></p>
<p>分割是对软件的纵向切分</p>
<p><strong>3.分布式</strong></p>
<p>网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快</p>
<p><strong>4.集群</strong></p>
<p>集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持</p>
<p><strong>5.缓存</strong></p>
<p>缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。</p>
<p>CDN/反向代理/热点数据</p>
<p><strong>6.异步</strong></p>
<p>异步是实现软件实体之间解耦合的又一重要手段。是典型的生产者消费者模式。</p>
<p><strong>7.冗余</strong></p>
<p>各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识图谱系列合集】一、知识提取</title>
    <url>/2020/08/14/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86%E3%80%91%E4%B8%80%E3%80%81%E7%9F%A5%E8%AF%86%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20200810201749355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="知识图谱构建流程"><br>数据主要有三类：结构化数据、半结构化数据和非结构化数据。<br>知识提取的目的：通过自动化或者半自动化的技术抽取出可用的知识单元，知识单元包括实体、属性和关系，并以此为基础，形成一系列高质量的事实表达，为上层模式层的构建奠定基础。<br>**<em>本文主要讲述知识图谱构建过程中的知识提取，实体抽取、属性抽取和关系抽取。**</em></p>
<a id="more"></a>

<p><strong><em>1.实体抽取</em></strong><br>实体抽取也称为命名实体学习，指的是从原始数据语料中自动识别出命名实体。实体是知识图谱中最基本的元素，所以实体抽取是知识抽取中最重要且最基础的一步。实体抽取的方法可以分为以下四种。</p>
<p><strong>1.1基于百科站点或垂直站点提取</strong><br>很常规基本的提取方法。<br>从百科类站点的标题和链接中提取实体名。优点是可以得到开放互联网中最常见的实体名，其缺点是对于中低频的覆盖率低。与一般性通用的网站相比，垂直类站点的实体提取可以获取特定领域的实体。例如从豆瓣各频道(音乐、读书、电影等)获取各种实体列表。这种方法主要是基于爬取技术来实现和获取。</p>
<p><strong>1.2基于规则与词典的方法</strong><br>需要为目标实体编写模板，然后在原始语料中进行匹配。<br>早期的实体抽取是在限定文本领域、限定语义单元类型的条件下进行的，主要采用的是基于规则与词典的方法，例如使用已定义的规则，抽取出文本中的人名、地名、组织机构名、特定时间等实体。然而，基于规则模板的方法不仅需要依靠大量的专家来编写规则或模板，覆盖的领域范围有限，而且很难适应数据变化的新需求。</p>
<p><strong>1.3基于统计机器学习的方法</strong><br>通过机器学习的方法对原始语料进行训练，然后再利用训练好的模型去识别实体。<br>鉴于基于规则与词典实体的局限性，为具更有可扩展性，相关研究人员将机器学习中的监督学习算法用于命名实体的抽取问题上。近年来随着深度学习的兴起应用，基于深度学习的命名实体识别得到广泛应用。</p>
<p><strong>1.4面向开放域的抽取方法</strong><br>是面向海量的Web语料。<br>针对如何从少量实体实例中自动发现具有区分力的模式，进而扩展到海量文本去给实体做分类与聚类的问题。</p>
<p><strong><em>2.属性和属性值抽取</em></strong><br>属性提取的任务是为每个本体语义类构造属性列表，而属性值提取则为一个语义类的实体附加属性值。属性和属性值的抽取能够形成完整的实体概念的知识图谱维度。常见的属性和属性值抽取方法包括从百科类站点中提取，从垂直网站中进行包装器归纳，从网页表格中提取，以及利用手工定义或自动生成的模式从句子和查询日志中提取。</p>
<p>常见的语义类/ 实体的常见属性/ 属性值可以通过解析百科类站点中的半结构化信息（如维基百科的信息盒和百度百科的属性表格）而获得。尽管通过这种简单手段能够得到高质量的属性，但同时需要采用其它方法来增加覆盖率（即为语义类增加更多属性以及为更多的实体添加属性值）。</p>
<p><strong><em>3.关系抽取</em></strong><br>关系抽取的目标是解决实体语义链接的问题。关系的基本信息包括参数类型、满足此关系的元组模式等。分为开放式实体关系抽取，基于联合推理的实体关系抽取等。</p>
<p><strong>3.1开放式实体关系抽取</strong><br>开放式实体关系抽取可分为二元开放式关系抽取和n元开放式关系抽取。</p>
<p>在二元开放式关系抽取中，早期的研究有KnowItAll与TextRunner系统，在准确率与召回率上表现一般。有文献提出了一种基于Wikipedia的OIE方法WOE，经自监督学习得到抽取器，准确率较TextRunner有明显的提高。针对WOE的缺点，有文献提出了第二代OIE ReVerb系统，以动词关系抽取为主。有文献提出了第三代OIE系统OLLIE(open language learning for information extraction)，尝试弥补并扩展OIE的模型及相应的系统，抽取结果的准确度得到了增强。</p>
<p>然而，基于语义角色标注的OIE分析显示：英文语句中40%的实体关系是n元的[32]，如处理不当，可能会影响整体抽取的完整性。有文献提出了一种可抽取任意英文语句中n元实体关系的方法KPAKEN，弥补了ReVerb的不足。但是由于算法对语句深层语法特征的提取导致其效率显著下降，并不适用于大规模开放域语料的情况。</p>
<p><strong>3.2基于联合推理的实体关系抽取</strong><br>联合推理的关系抽取中的典型方法是马尔可夫逻辑网，它是一种将马尔可夫网络与一阶逻辑相结合的统计关系学习框架，同时也是在OIE中融入推理的一种重要实体关系抽取模型。</p>
<p>联合推理的关系抽取中的典型方法是马尔可夫逻辑网MLN，它是一种将马尔可夫网络与一阶逻辑相结合的统计关系学习框架，同时也是在OIE中融入推理的一种重要实体关系抽取模型。基于该模型，有文献提出了一种无监督学习模型StatSnowball，不同于传统的OIE，该方法可自动产生或选择模板生成抽取器。在StatSnowball的基础上，有文献提出了一种实体识别与关系抽取相结合的模型EntSum，主要由扩展的CRF命名实体识别模块与基于StatSnowball的关系抽取模块组成，在保证准确率的同时也提高了召回率。有文献提出了一种简易的Markov逻辑TML(tractable Markov logic)，TML将领域知识分解为若干部分，各部分主要来源于事物类的层次化结构，并依据此结构，将各大部分进一步分解为若干个子部分，以此类推。TML具有较强的表示能力，能够较为简洁地表示概念以及关系的本体结构。</p>
<p><strong><em>4.语义类提取</em></strong><br>语义类抽取是指从文本中自动抽取信息来构造语义类并建立实体和语义类的关联, 作为实体层面上的规整和抽象。以下介绍有效的语义类抽取方法，包含三个模块：并列度相似计算、上下位关系提取以及语义类生成 。</p>
<p><strong>4.1并列度相似计算</strong><br>当前主流的并列相似度计算方法有分布相似度法和模式匹配法。</p>
<p>分布相似度方法：经常出现在类似的上下文环境中的两个词具有语义上的相似性。分布相似度方法的实现分三个步骤：第一步，定义上下文；第二步，把每个词表示成一个特征向量，向量每一维代表一个不同的上下文，向量的值表示本词相对于上下文的权重；第三步，计算两个特征向量之间的相似度，将其作为它们所代表的词之间的相似度。 、</p>
<p>模式匹配法：基本思路是把一些模式作用于源数据，得到一些词和词之间共同出现的信息，然后把这些信息聚集起来生成单词之间的相似度。模式可以是手工定义的，也可以是根据一些种子数据而自动生成的。</p>
<p>分布相似度法和模式匹配法都可以用来在数以百亿计的句子中或者数以十亿计的网页中抽取词的相似性信息。。</p>
<p><strong>4.2上下位关系提取</strong><br>该模块从文档中抽取词的上下位关系信息，生成（下义词，上义词）数据对，例如（狗，动物）、（悉尼，城市）。这种方法的主要缺点包括：并不是所有的分类词条都代表上位词，例如百度百科中“狗”的开放分类“养殖”就不是其上位词；生成的关系图中没有权重信息，因此不能区分同一个实体所对应的不同上位词的重要性；覆盖率偏低，即很多上下位关系并没有包含在百科站点的分类信息中。</p>
<p><strong>4.3语义类生成</strong><br>该模块包括聚类和语义类标定两个子模块。聚类的结果决定了要生成哪些语义类以及每个语义类包含哪些实体，而语义类标定的任务是给一个语义类附加一个或者多个上位词作为其成员的公共上位词。此模块依赖于并列相似性和上下位关系信息来进行聚类和标定。有些研究工作只根据上下位关系图来生成语义类，但经验表明并列相似性信息对于提高最终生成的语义类的精度和覆盖率都至关重要。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识图谱系列合集】三、实体对齐</title>
    <url>/2020/08/14/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86%E3%80%91%E4%B8%89%E3%80%81%E5%AE%9E%E4%BD%93%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20200810204859835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>导读：</em></strong></p>
<ul>
<li>1.<a href="https://blog.csdn.net/zkzbhh/article/details/107921135">知识提取</a>：从原始数据语料中自动识别出命名实体。实体是知识图谱中最基本的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zkzbhh/article/details/107921135</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2.<a href="https://blog.csdn.net/zkzbhh/article/details/107921258">知识表示</a>：介绍了知识表示学习的常见的代表模型：距离模型、单层神经网络模型、能量模型、双线性模型、张量神经网络模型、矩阵分解模型。翻译模型（Trans模型）,TransH模型、TransR模型、TransD模型、TranSpare模型、TransA模型、TransG模型、KG2E模型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zkzbhh/article/details/107921258</span></span><br></pre></td></tr></table></figure>
<p><strong>本篇文章，我们介绍实体对齐的相关内容，包括实体消歧和共指消歧。</strong></p>
<a id="more"></a>

<p><strong><em>一、实体消歧</em></strong><br><strong>含义</strong>：实体消歧的本质在于一个词有很多可能的意思，也就是在不同的上下文中所表达的含义不太一样。</p>
<p><strong>例子</strong>：<br><img data-src="https://img-blog.csdnimg.cn/20200810205414690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>“我的手机是苹果”和”我喜欢吃苹果”这两个句子中的“苹果”代表的含义是不一样的。前者代表是手机、后者代表是水果。</p>
<p><strong>具体实现</strong>：</p>
<p>“美国一家高科技公司，经典的产品有Iphone手机”转换为向量 [公式] ；“水果的一种，一般产自于…”转换为向量 [公式] ；然后将“今天苹果发布了新的手机”中“苹果”的上下文“今天，发布了新的手机”转换为向量 [公式] ;我们只要将 [公式] 分别与 [公式] 和 [公式] 计算相似度，然后对比 [公式] 和 [公式] ;相似度高的，我们则将其看作“苹果”的真实语义。</p>
<p><strong><em>二、共指消歧</em></strong></p>
<p>共指消解，也叫指代消解。很难因为自然语言充满歧义，因此必须使用多种信号和知识来消除歧义。需要基于对周围世界的了解才能明白这些指代，而这种知识很难编码到计算机中。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">乔布斯改变了我们听音乐、购买音乐、打电话、使用手机、看电影等各方面的体验。当他去世时，奥巴马称他为最伟大的创新者。</span><br></pre></td></tr></table></figure>
<p>上面这句话中的他指代的是乔布斯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">乔布斯改变了我们听音乐、购买音乐、打电话、使用手机、看电影等各方面的体验。当他听到这个消息，奥巴马致电慰问他的妻子。</span><br></pre></td></tr></table></figure>
<p>那这段话中的他指代的是奥巴马。</p>
<p>指代消解主要有两个步骤。第一步是指代识别（mention detection），即找出句子中所有的指代，这一步相对简单。第二步才是进行真正的指代消解（coreference resolution），这一步比较难。</p>
<p><strong>1.指代识别</strong></p>
<p>指代识别阶段尽量保召回率，保留所有找到的可能是指代的词，都参与后期的指代消解。如果一个指代没有找到它的共同指代（coreference），则说明这个指代是孤立的（singleton mention），有可能是指代识别阶段找到的不是指代的词，直接舍弃。</p>
<p><strong>2.指代消解</strong></p>
<p>指代消解发展至今，经历了四种不同的方法，分别是Rule-based、Mention pair、Mention Ranking。</p>
<p><strong>Rule-based方法</strong>：1976年，Hobbs提出了基于规则的朴素算法，被后人称为Hobbs算法。该方法有9个步骤，包含了很多规则，非常繁琐。Hobbs算法虽然是基于规则的，但在当时取得了不错的效果，现在也常常作为该领域的baseline模型。但是因为该方法是基于规则的，有很多指代消解没法解决。</p>
<p><strong>Mention pair方法</strong>：该方法把指代消解问题转化为一个二分类问题。从左到右遍历句子，每找到一个指代，就把它和前面找到的每个指代作为一个pair，问分类器这个pair是否指代同一个实体，如果是的话，就把它们连起来。二分类的损失就是交叉熵。很简单的一个模型。</p>
<p><strong>Mention Ranking</strong>：每个指代同时和前面所有指代打分，用softmax归一化，找出概率最大的先行词，添加一条连边。注意需要添加一个NA节点，因为有的指代可能第一次出现，前面没有先行词，或者这个指代根本就不是一个真正的指代。</p>
<p>前面的内容都是假设我们计算好了任意两个指代是coreference的概率，那么，如何来计算这个概率呢？主要有三种方法，分别是Non-neural statistical classifier、Simple neural network和More advanced model using LSTMs, attention。</p>
<p><strong>A. Non-neural statistical classifie</strong>r。统计机器学习方法，抽取每个指代的各种特征，然后用机器学习分类器来计算两个指代是coreference的概率。这里面的特征包括人称、性别一致性，语义相容性等等。</p>
<p><strong>B. Neural Coref Model</strong>。输入是候选先行词和当前指代词的词向量，还需要加入一些额外的特征（Additional Feature），也就是上面统计机器学习方法里用到的一些特征。中间是FFNN，即全连接网络，最后输出两个指代是coreference的概率。</p>
<p><strong>C. End-to-end Model</strong>。end2end模型是目前指代消解的SOTA模型，它把指代识别和指代消解两个任务融合到一起，用一个模型来解决。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱 实体对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识图谱系列合集】二、知识表示</title>
    <url>/2020/08/14/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E3%80%81%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20200810202240689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="知识图谱构建流程"><br>将结构化、半结构化和非结构化数据中的实体、关系和属性进行提取。之后就要进行知识表示。本文主要介绍知识表示的概念、常见的代表模型：距离模型、单层神经网络模型、能量模型、双线性模型、张量神经网络模型、矩阵分解模型和Trans系列模型。</p>
<a id="more"></a>

<p><strong><em>说明：</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">摘自刘知远：知识表示学习研究进展（DOI;<span class="number">10.7544</span>/issn1000-<span class="number">1239.2016</span>.<span class="number">20160020</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>导读：</em></strong></p>
<ul>
<li><a href="https://blog.csdn.net/zkzbhh/article/details/107921135">知识提取</a></li>
</ul>
<p><strong><em>目录：</em></strong></p>
<ul>
<li>一、知识表示学习概念</li>
<li>二、知识表示学习主要方法</li>
</ul>
<p><strong><em>一.知识表示学习的概念</em></strong><br><strong>one-hot representation</strong>：将研究对象表示为向量，该向量只有某一维非零，其它维度上的值均为0，独热表示是信息检索和搜索引擎中广泛使用的词袋模型的基础。优点是无需学习过程，简单高效，在信息检索和自然语言处理中得到广泛应用。缺点是会丢失大量有用信息，无法有效表示短文本、容易受到数据稀疏问题的影响。</p>
<p><strong>表示学习的目标</strong>：通过机器学习将研究对象的语义信息表示为稠密低维实值向量。将实体e和关系r表示为两个不同向量，在向量空间中，通过欧式距离或余弦距离等方式，计算任意两个对象之间的语义相似度。</p>
<p>知识表示学习得到的分布式表示，我们可以快速计算实体间的语义相似度，这对于自然语言处理和信息检索的很多任务有重要意义；我们还可以知识图谱补全，构建大规模知识图谱，需要不断补充实体间的关系，利用知识表示学习模型，我们可以预测2个实体的关系；除此之外，还可以用于关系抽取，自动问答，实体链指等任务，展现出巨大的应用潜力。</p>
<p><strong>知识表示学习的优点</strong>：显著提升计算效率，知识库的三元组表示实际就是基于独热表示的，在这种表示方式下，需要设计专门的图算法计算实体间的语义和推理关系，计算复杂度高、可扩展性差。而表示学习得到的分布式表示，能够高效地实现语义相似度计算等操作，显著提升计算效率；有效缓解数据稀疏；实现异质信息融合。</p>
<p><strong><em>二.知识表示学习的主要方法</em></strong><br>知识表示学习的代表模型，包括距离模型、单层神经网络模型、能量模型、双线性模型、张量神经网络模型、矩阵分解模型和翻译模型，还有最重要的Trans系列模型。</p>
<p><strong>1.距离模型（SE）</strong></p>
<p>每个实体用d维的向量表示，所有实体被投影到同一个d维向量空间中，同时，距离模型还未每个关系r定义2个矩阵，用于三元组中头实体和尾实体的投影操作。最后，距离模型为每个三元组（h,r,t）定义了如下损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810202439393.png" alt="距离模型的损失函数"><br>距离模型的<strong>损失函数</strong><br><img data-src="https://img-blog.csdnimg.cn/2020081020250574.png" alt="在这里插入图片描述"><br>距离模型将头实体向量和尾实体向量通过关系r的2个矩阵投影到r的对应空间中，然后在该空间中计算两投影向量的距离。这个距离反映了2个实体在关系r下的语义相似度，他们距离越小，说明这2个实体存在这种关系。</p>
<p>距离模型能够利用学习得到的知识表示进行链接预测，即通过计算，找到让两实体距离最近的关系矩阵。</p>
<p>距离模型的缺陷：协同性差，无法精确刻画两个实体之间的语义联系</p>
<p><strong>2.单层神经网络模型(SLM）</strong></p>
<p>采用单层神经网络的非线性操作，来减轻距离模型无法协同精确刻画实体与关系的语义联系的问题。SLM为每个三元组（h,r,t）定义了评分函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810202546740.png" alt="在这里插入图片描述"><br>SLM是SE模型的改进版本，但是它的非线性操作仅提供了实体和关系之间比较微弱的联系，与此同时，引进了更高的计算复杂度。</p>
<p><strong>3.能量模型（SME）</strong></p>
<p>语义匹配能量模型，提出更复杂的操作，寻找实体和关系之间的语义联系。在SME中，每个实体和关系都用低维向量表示，在此基础上，SME定义若干投影矩阵，刻画实体与关系的内在联系，SME为每个三元组（h,r,t）定义了2种评分函数，分别是线性形式：<br><img data-src="https://img-blog.csdnimg.cn/20200810202602385.png" alt="在这里插入图片描述"><br>和双线性形式：<br><img data-src="https://img-blog.csdnimg.cn/20200810202614946.png" alt="在这里插入图片描述"><br>此外，也可以用三阶张量代替SME的双线性形式。</p>
<p><strong>4.双线性模型（LFM）</strong></p>
<p>隐变量模型提出利用基于关系的双线性变换，刻画实体和关系之间的二阶关系，LFM为每个三元组（h,r,t）定义了如下双线性评分函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810202720407.png" alt="在这里插入图片描述"></p>
<p><strong>5.张量神经网络模型（NTN）</strong></p>
<p>张量神经网络模型的基本思想是，用双线性张量取代传统神经网络中的线性变换层，在不同的维度下将头、尾实体向量联系起来。基本思想如下图：<br><img data-src="https://img-blog.csdnimg.cn/20200810202751191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>张量神经网络模型<br>NTN为每个三元组（h,r,t）定义了如下评分函数，评价2个实体之间存在的某个特定关系r的可能性：<br><img data-src="https://img-blog.csdnimg.cn/20200810202805711.png" alt="在这里插入图片描述"><br>NTN中的实体向量是该实体中所有单词向量的平均值，这样做的好处是，实体中的单词数量远小于实体数量，可以充分重复利用单词向量构建实体表示，降低实体表示学习的稀疏性问题，增强不同实体的语义联系。</p>
<p>NTN的缺陷：虽然能够更精确地刻画实体和关系的复杂语义联系，但复杂度非常高，需要大量三元组样例才能得到充分学习，NTN在大规模稀疏知识图谱上的效果较差。</p>
<p><strong>6.矩阵分解模型（RESACL）</strong></p>
<p>知识库三元组构成了一张大的张量X，如果三元组（h,r,t）存在，则X=1，否则为0.张量分解旨在将每个三元组（h,r,t）对应的张量值X分解为实体和关系表示，使得X尽量地接近于LML</p>
<p>RESACL的基本思想与前述LFM类似，不同之处在于，RESACL会优化张量中的所有位置，包括0的位置；而LFM只会优化知识库中存在的三元组。</p>
<p><strong>7.Trans系列模型</strong><br><strong>7.1TransH模型</strong><br>在处理1-N，N-1，N-N复杂关系时的局限性，TransH模型提出让一个实体在不同的关系下拥有不同的表示。<br><img data-src="https://img-blog.csdnimg.cn/20200810203540774.png" alt="在这里插入图片描述"><br>损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810203556520.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20200810203617402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="TransH model"><br><strong>7.2TransR/CTransR模型</strong></p>
<p>虽然TransH模型使每个实体在不同关系下拥有不同的表示，它仍然假设实体和关系处于相同的语义空间R中，在一定程度上限制了TransH的表达能力。TransR模型认为，一个实体是多种属性的综合体，不同关系关注实体的不同属性。TransR认为不同的关系拥有不同的语义空间，对每个三元组，首先应将实体投影到对应的关系空间中，然后再建立从头实体到尾实体的翻译关系。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200810204641888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>上图是TransR模型的简单示例，对于每个三元组（h,r,t），我们首先将实体向量向关系r空间投影，原来在实体空间中与头（圆圈表示）、尾实体相似的实体（三角形表示），在关系r空间内被区分开了。具体而言，对于每一个关系r，TransR表示如下：<br><img data-src="https://img-blog.csdnimg.cn/20200810203754256.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20200810203800147.png" alt="[公式]"><br>因此 TransR定义了如下损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810203823358.png" alt="在这里插入图片描述"><br>相关研究表明，某些关系还可以进行更细致的划分。于是，Lin等人进一步提出了CTransR模型，通过把关系r对应的实体对的向量差值 进行聚类，将关系r细分为多个子关系.CTransR模型为每一个子关系分别学习向量表示，对于每个三元组，定义了如下损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810203853566.png" alt="在这里插入图片描述"><br><strong>TransR模型的缺点：</strong><br>（1）在同一个关系r下，头、尾实体共享相同的投影矩阵。然而，一个关系的头、尾实体的类型或属性可能差异巨大。例如（美国，总统，奥巴马），美国和奥巴马的类型不同，一个是国家，一个是人物。<br>（2）从实体空间到关系空间的投影是实体和关系的交互过程。因此TransR让投影矩阵仅与关系有关是不合理的。<br>（3）与TransE和TransH相比，TransR引入了空间投影，使得TransR模型参数急剧增加，计算复杂率大大提高。</p>
<p><strong>7.3TransD模型</strong></p>
<p>为了解决TransR模型的缺点，Ji等人提出了TransD模型，如下图所示，给定三元组,TransD模型设置了2个分别将头实体和尾实体投影到关系空间的投影矩阵，具体定义如下：<br><img data-src="https://img-blog.csdnimg.cn/20200810203940111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20200810203954891.png" alt="[公式] ， [公式]"><br>利用2个投影向量构建投影矩阵，解决了原来TransR模型参数过多的问题。最后，TransD模型定义了损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810204006764.png" alt="[公式]"><br><strong>7.4TransSpare模型</strong></p>
<p>知识库中实体和关系的异质性和不平衡性是制约知识表示学习的难题：<br>（1）异质性：知识库中某些关系可能会与大量的实体有连接，而某些关系则可能仅仅与少量实体有连接。</p>
<p>（2）不均衡性：在某些关系中，头实体和尾实体的种类和数量可能差别巨大。</p>
<p>为了解决实体和关系的异质性。TransSparse提出使用稀疏矩阵 [公式] 的稀疏度由关系r连接的实体对数量决定。这里头、尾实体共享同一个投影矩阵，投影矩阵的稀疏度定义如下：<br><img data-src="https://img-blog.csdnimg.cn/20200810204037748.png" alt="在这里插入图片描述"><br>这样，投影向量可定义为：<br><img data-src="https://img-blog.csdnimg.cn/20200810204049578.png" alt="[公式] , [公式]"><br>为了解决关系的不平衡性问题，TranSparse对于头实体和尾实体分别使用2个不同的投影矩阵.;两者的稀疏度定义如下：<br><img data-src="https://img-blog.csdnimg.cn/20200810204103696.png" alt="在这里插入图片描述"><br>这样，投影向量可定义为：<br><img data-src="https://img-blog.csdnimg.cn/20200810204120186.png" alt="[公式] , [公式]"><br>TranSparse对于以上2种形式，均定义如下损失函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810204130645.png" alt="在这里插入图片描述"><br><strong>7.5TransA模型</strong><br><strong>加粗样式</strong><br>Xiao等人提出TransA模型，将损失函数中的距离度量改为马氏距离，并为每一维学习不同的权重，对于每个三元组.TransA模型定义了如下评分函数：<br><img data-src="https://img-blog.csdnimg.cn/20200810204428630.png" alt="在这里插入图片描述"><br>如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/20200810204419823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>7.6 TransG模型</strong></p>
<p>TransG模型提出使用高斯混合模型描述头、尾实体之间的关系。该模型认为，一个关系会对应多种语义，每种语义用一个高斯分布来刻画，其中I表示单位矩阵。<br><img data-src="https://img-blog.csdnimg.cn/20200810204517797.png" alt="在这里插入图片描述"><br>TransG模型与传统模型的对比如下图所示。其中三角形表示正确的尾实体，圆形表示错误的尾实体。<br><img data-src="https://img-blog.csdnimg.cn/20200810204459833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图(a)中为传统模型示例，由于将关系r的所有语义混为一谈，导致错误的实体无法被区分开，而图(b)所示，TransG模型通过考虑关系r的不同语义，形成多个高斯分布，就能区分出正确和错误实体。</p>
<p><strong>7.7KG2E模型</strong></p>
<p>知识库中的关系和实体的语义 本身具有不确定性，这在过去模型中被忽略了。因此He等人提出KG2E，使得高斯分布来表示实体和关系。其中高斯分布的均值表示的是实体或关系在语义空间中的中心位置，而高斯分布的协方差则表示该实体或关系的不确定度。下图为KG2E的模型示例，每个圆圈代表不同实体与关系的表示，其中圈圈大小表示的是不同实体或关系的不确定度。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>知识表示</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识图谱系列合集】四、知识存储</title>
    <url>/2020/08/14/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86%E3%80%91%E5%9B%9B%E3%80%81%E7%9F%A5%E8%AF%86%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20200810210037352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong><em>导读：</em></strong></p>
<ul>
<li>1.<a href="https://blog.csdn.net/zkzbhh/article/details/107921135">知识提取</a>：从原始数据语料中自动识别出命名实体。实体是知识图谱中最基本的元素。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zkzbhh/article/details/107921135</span></span><br></pre></td></tr></table></figure></li>
<li>2.<a href="https://blog.csdn.net/zkzbhh/article/details/107921258">知识表示</a>：介绍了知识表示学习的常见的代表模型：距离模型、单层神经网络模型、能量模型、双线性模型、张量神经网络模型、矩阵分解模型。翻译模型（Trans模型）,TransH模型、TransR模型、TransD模型、TranSpare模型、TransA模型、TransG模型、KG2E模型。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zkzbhh/article/details/107921258</span></span><br></pre></td></tr></table></figure></li>
<li>3.<a href="https://blog.csdn.net/zkzbhh/article/details/107921782">实体对齐</a>：介绍实体消歧和共指消歧的方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zkzbhh/article/details/107921782</span></span><br></pre></td></tr></table></figure>
<strong>本篇文章，主要介绍知识图谱的知识存储。</strong></li>
</ul>
<a id="more"></a>

<p><strong><em>1.RDF、RDFS和OWL数据模型</em></strong></p>
<p>RDF、RDFS和OWL是W3C[1]推荐的本体描述用护眼，也是知识图谱中数据的常用存储格式，它们都是基于XML[2]编写的元数据[3]，是用于计算机传输数据，让机器可理解，而不是面向用户展示的数据模型。</p>
<p><strong>(1)RDF</strong></p>
<p>RDF本质是一个数据模型，它提供了一个统一的标准描述web资源，资源指的是类、属性、实例等。RDF在形式上表示为三元组。用于描述具体事物及关系，RDF也可以表示为一张带有标记的有向图，图中有节点和边，节点对应实体，边对应关系或者属性，关系指的是实体之间，实体与属性之间的关系。</p>
<p><strong>RDF中的三元组Triple：</strong><br><img data-src="https://img-blog.csdnimg.cn/20200810210302969.png" alt="在这里插入图片描述"></p>
<p><strong>带有资源标识符URI的三元组：</strong><br><img data-src="https://img-blog.csdnimg.cn/20200810210200426.png" alt="在这里插入图片描述"><br>声明命名空间ex = <a href="http://ex.org/%E5%92%8Cex-schema">http://ex.org/和ex-schema</a> = <a href="http://ex.org/schema%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%B8%A6%E6%9C%89%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84URI%E4%B8%89%E5%85%83%E7%BB%84%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BA%E4%B8%8B%E5%9B%BE%E5%BD%A2%E5%BC%8F%E3%80%82">http://ex.org/schema，于是带有资源标识符的URI三元组就可以表示为下图形式。</a></p>
<p><strong>声明前缀的三元组：</strong><br><img data-src="https://img-blog.csdnimg.cn/20200810210239944.png" alt="在这里插入图片描述"></p>
<p>RDF以三元组的形式描述资源，简洁明了，但是有着语义表达能力的缺陷。RDF中没有定义类、属性等词汇。RDF只能是对具体的事物进行描述，缺乏抽象能力，无法对同一个类别的事物进行定义和描述。RDF可以描述实体、实体的属性以及他们之间的关系，但是无法描述类与类之间的关系，类的属性等</p>
<p><strong>(2)RDFS</strong></p>
<p>RDFS在RDF的基础上定义了类（class）、属性（property）以及关系（relation）来描述资源，并且通过属性的定义域（domain）和值域（range）来约束资源。RDFS在数据层（data）的基础上引入了模式层（schema），模式层定义了一种约束规则，而数据层是在这种规则下的一个实例填充。</p>
<p>RDFS相比于RDF语义表达能力有所提升，但RDFS依旧有语义表达的缺陷。在RDFS中关于类与类之间的关系它只能声明子类关系，无法声明互斥类的关系，也无法声明多个类、实例、属性是否等价。</p>
<p><strong>(3)OWL</strong></p>
<p>OWL是对RDFS关于描述资源词汇的一个扩展，OWL中添加了额外的预定于词汇来描述资源，具备更好的语义表达能力。在OWL中可以声明资源的等价性，属性的传递性、互斥性、函数性、对称性等等，具体见OWL的词汇扩展。</p>
<p>本体和知识图谱在构建过程中，数据的存储常以RDF格式存放。而基于RDF数据的结构化查询语言SPARQL，可以实现对三元组的查询。在SPARQL中，常以“？”来表示变量或者资源标识符，select子句检索指定资源的资源标识符，where子句限定资源的由来。</p>
<p><strong><em>2.基于RDF的存储</em></strong></p>
<p>大部分开放的知识图谱，都是以RDF形式对外开放。</p>
<p><strong>RDF结构：</strong></p>
<p>RDF 为描述资源提供的基本元素有 IRI，字面值和空节点 (blank node)。IRI 就是一个符合特定语法的 UINICODE 字符串，跟 URL 的形式比较类似。其实 URL 属于 IRI 的一种。字面值可以理解为像时间、人名、数字等常量的表示，由字符串和表示数据类型的 IRI 构成。例如数字 1 的字面值可以表示为”1”^^xs:integer，其中 xs:integer 是表示整型数据类型的 IRI。空节点是指没有 IRI 的匿名节点。一般是 RDF 内部使用的一个特殊结构，不可被引用。</p>
<p><strong>一个 RDF 数据集由一组相关的三元组的组成。</strong>由于这个三元组集合可以抽象为一张 graph，因此也称为 RDF graph。</p>
<p><strong>例如，</strong>用 RDF 描述一本书，RDF 字典就需要定义一本书需要包含作者、书名、页数、出版时间、语言类型等。RDF 字典定义了数据建模的元数据项，这些元数据项主要包括两种类型 class 和 property。Class 是指对象实例的集合，可以理解为面向对象编程里的 class；Property 还分为两种子类型：一个是表示 class 的属性 (attribute)，另一个是表示多个 class 之间的关系 (relationship)。</p>
<p>另外，RDF 字典的定义自身也是一个 RDF graph。这也是说明 RDF 是自描述的数据模型，是一种 schema-free 的数据模型。</p>
<p><strong><em>3.基于图数据库的存储</em></strong></p>
<p>图数据库是一种非关系型数据库，以解决现有关系数据库的局限性。图模型明确地列出了数据节点之间的依赖关系，而关系模型和其他 NoSQL 数据库模型则通过隐式连接来链接数据。图数据库从设计上，就是可以简单快速地检索难以在关系系统中建模的复杂层次结构的。</p>
<p><strong>以neo4j为例介绍。</strong></p>
<p>数据存储形式：主要是 <strong>节点（node）和 边（edge）</strong> 来组织数据。node可以代表知识图谱中的实体，edge可以用来代表实体间的关系，关系可以有方向，两端对应开始节点和结束节点。另外，可以在node上加一个或多个<strong>标签（Node Label）表示实体的分类</strong>，以及一个键值对集合来表示该实体除了关系属性之外的一些额外属性。关系也可以附带额外的属性。</p>
<p>查询语言Cypher：neo4j采用自己设计的查询语言cypher，其特点和sql有很多相似的地方。<strong>match、where、return</strong>是最常用到的关键词：</p>
<ul>
<li>match: 相当于 sql中的select，用来说明<strong>查询匹配的数据模式</strong>（或者说图模式）</li>
<li>where: 用来限制node或者关系中部分属性的属性值，从而返回我们想要的数据</li>
<li>return: 返回节点或者关系</li>
</ul>
<p><strong>例子：</strong><br><img data-src="https://img-blog.csdnimg.cn/20200810210539178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70" alt="图片来自网络，侵权删"></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱 知识存储</tag>
      </tags>
  </entry>
  <entry>
    <title>工业机理</title>
    <url>/2020/08/17/%E5%B7%A5%E4%B8%9A%E6%9C%BA%E7%90%86/</url>
    <content><![CDATA[<h4 id="工业机理模型可以实现四类功能"><a href="#工业机理模型可以实现四类功能" class="headerlink" title="工业机理模型可以实现四类功能"></a>工业机理模型可以实现四类功能</h4><ol>
<li><strong>描述</strong>，描述设备、工艺发生了什么；</li>
<li><strong>诊断</strong>，发生了什么问题、什么地方发生了问题；</li>
<li><strong>预测</strong>，如果不处理设备将有什么问题，能耗会有什么问题，质量会有什么问题；</li>
<li><strong>决策</strong>、最后怎么办，是对那个环节进行维修，那个环节进行优化，或者保养，增加或者减少物料的输入等等，给操作手、给总工、给管理层提供一个解决方案。</li>
</ol>
<a id="more"></a>

<h4 id="机理模型落地，会有四个阶段："><a href="#机理模型落地，会有四个阶段：" class="headerlink" title="机理模型落地，会有四个阶段："></a>机理模型落地，会有四个阶段：</h4><ol>
<li><strong>理论推理</strong>，把工业中的热平衡、物质平衡等通过抽象的方法形成理论模型；</li>
<li><strong>实验验证</strong>，对理论模型进行实验验证，仿真验证的过程；</li>
<li><strong>模拟择优</strong>，在虚拟世界里面去完成，通过大数据模拟选择最优的结果；</li>
<li>大数据分析通过模拟＋大数据发现新的规律。</li>
</ol>
<h4 id="机理模型分类"><a href="#机理模型分类" class="headerlink" title="机理模型分类"></a><strong>机理模型分类</strong></h4><p>1.机理模型（白箱）：存在物理关系，通过物理或数学公式来概化表达的模型。这类模型存在在各行各业。根据对象、生产过程的内部机制或者物质流的传递机理建立起来的精确数学模型。它是基于质量平衡方程、能量平衡方程、动量平衡方程、相平衡方程以及某些物性方程、化学反应定律、电路基本定律等而获得对象或过程的数学模型。机理模型的优点是参数具有非常明确的物理意义。</p>
<p>2.非机理模型（黑箱或灰箱）：人工智能，以神经网络为代表，当然也有决策树、遗传算法以及支持向量机等等</p>
<hr>
<p>以后的趋势必然是机器学习与传统数学模型融合。</p>
<p><strong>人工智能</strong>——&gt;深度学习——&gt;<strong>神经网络(模型)**——&gt;计算机视觉——&gt;**工业界</strong>（自动驾驶、安防、医疗）</p>
<p><a href="https://cloud.tencent.com/developer/news/25568">https://cloud.tencent.com/developer/news/25568</a></p>
<p>例如：SVM与传统的内涝数学模型有机结合在一起</p>
<p>基于物理过程的数学模型已经广泛应用于城市内涝模拟中，但是数值模型在应用到实时内涝预报中，最大的瓶颈既是需要大量的计算资源和模拟时间，虽然有各种各样的简化模型技术被提出来，但是这些技术往往只能应用在满足一定前提条件的项目中</p>
<p><strong>首先，数据在哪里？</strong></p>
<p>▲一类是管理数据：结构化的SQL数据为主，如产品属性、工艺、生产、采购、订单、服务等数据，这类数据一般来自企业的ERP、SCM、PLM甚至MES等系统，数据量本身不大，却具有很大的挖掘价值；</p>
<p>▲另一类则是机器运行和IoT的数据：以非结构化、流式数据居多，如设备工况（压力、温度、振动、应力等）、音视频、日志文本等数据，这类数据一般采集自设备PLC、SCADA以及部分外装传感器，数据量很大，采集频率高，需要结合边缘计算在本地做一些预处理。</p>
<p>总的来讲，由于场景的割裂和分散，工业数据本身具有量大、多源、异构、实时性要求高等特点，而且随着未来280亿设备逐步接入，这些特性将会进一步加强，这是做工业大数据服务的核心难点之一，和互联网大数据不仅量级不同，结构不同，应用也完全不同。</p>
<p><strong>其次，基于这些工业数据，平台层应该提供哪些服务？</strong></p>
<p>▲完整的协议解析：数据采集首先要完成工业协议的打通。以应用层协议为例，EtherNet/IP和PROFINET的市场占有率最大，其次是EtherCAT、Modbus-TCP和EtherNetPOWERLINK；</p>
<p>▲标准化的数据整合：采集上来的数据要做统一的主数据管理，第一步是建立标准。一般来讲，我们先要用ISO或其他业内标准，制定统一的编码、结构、流转方式和属性，确保数据的一致性，这一点非常重要。</p>
<p>在项目实施的历程中，逐步积累行业知识库、合适的算法组件以及相关机理模型，这一点也很重要，这是从数据标准进化到业务标准化的关键一步，是为实现真正的产品层面的微服务化打下基础。</p>
<p>强大的PaaS支持：工业数据本身的特殊性导致平台必须要有强大的中层支撑能力。我们以时序数据库为例，它是设备工况和传感器数据的典型品种。这类数据频率高、量大，用传统关系型数据库处理，需要每次把所有值拉出来计算，吞吐量极大，性能很差。所以，一个高压缩、高性能的时序数据库，就是平台层必备的能力之一。</p>
<p><strong>最后，我们应该做哪些应用？</strong></p>
<p>▲设备级：质量控制。在工业智能时代，如果我们能够采集到合适的实时数据，结合该设备所适用的机理模型，就有可能用机器学习的方法挖掘出产品质量与关键数据之间的关联或因果关系，也就有可能实现实时在线的质量控制和故障预警，如果数据频率能对工艺流程形成完美包络，我们还有可能实现最大限度的效率提升。</p>
<p>▲厂级：计划排产。工业智能的最终目的是要实现大规模的个性化定制，即C2M。这一问题的目标是实现当时当地的产能最优，约束条件来自企业的产线设备、人员、产品属性、供应链数据等等，通过历史数据的学习和训练，不难形成一个较好的预测模型。</p>
<p>这一模型能根据产线和工厂的实时数据动态分析，动态调整，以帮助企业实现准确把控，最大化经济效益。</p>
]]></content>
      <categories>
        <category>工业机理模型</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>工业机理</tag>
      </tags>
  </entry>
  <entry>
    <title>命令集合</title>
    <url>/2020/08/14/%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>生成阅读全文，在markdowm文本中插入：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>初始化并安装所需组件：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure>

<p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure>

<p>首先<strong>安装 hexo-deployer-git</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>清楚缓存等文件并重新发布网站：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean   <span class="comment"># 清除缓存文件等</span></span><br><span class="line">hexo g       <span class="comment"># 生成页面</span></span><br><span class="line">hexo s       <span class="comment"># 启动预览</span></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo deploy #部署发布</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>先建页面</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>&quot;<span class="built_in">this</span> is a <span class="keyword">new</span> <span class="type">md</span>&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>方法技巧</category>
      </categories>
      <tags>
        <tag>方法技巧</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
<ol>
<li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="如何杀死一个进程"><a href="#如何杀死一个进程" class="headerlink" title="如何杀死一个进程"></a>如何杀死一个进程</h2><p>kill pid</p>
<h2 id="socket编程的三种通信模型，BIO，NIO，AIO"><a href="#socket编程的三种通信模型，BIO，NIO，AIO" class="headerlink" title="socket编程的三种通信模型，BIO，NIO，AIO"></a>socket编程的三种通信模型，BIO，NIO，AIO</h2><p>阻塞，非阻塞，io多路复用，epoll支持文件符数目没有限制，fd集合只会从用户进程拷贝到内核一次，自己维护一个事件队列，不用每次遍历fd集合发现是否有就绪状态。</p>
<h2 id="操作系统里的内存碎片，有什么解决办法"><a href="#操作系统里的内存碎片，有什么解决办法" class="headerlink" title="操作系统里的内存碎片，有什么解决办法"></a>操作系统里的内存碎片，有什么解决办法</h2><p>内存碎片分为：内部碎片和外部碎片。</p>
<p>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p>
<p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p>
<h2 id="页面存储"><a href="#页面存储" class="headerlink" title="页面存储"></a>页面存储</h2><p>主存被等分成大小相等的片，称为主存块，又称为实页。</p>
<p>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2n ,通常为1KB、2KB、2n KB等</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法|排序</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><img data-src="https://uploadfiles.nowcoder.com/images/20180927/308572_1538031578438_AEAC18AEF8824A88CF86B273C90F0BCC" alt="img"></p>
<a id="more"></a>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快排：快速排序有两个方向，左边的i下标一直往右走（当条件a[i] &lt;= a[center_index]时），其中center_index是中枢元素的数组下标，一般取为数组第0个元素。</p>
<p>而右边的j下标一直往左走（当a[j] &gt; a[center_index]时）。</p>
<p>如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。交换a[j]和a[center_index]，完成一趟快速排序。</p>
<h2 id="堆排序的原理"><a href="#堆排序的原理" class="headerlink" title="堆排序的原理"></a>堆排序的原理</h2><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p>
<p>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</p>
<p>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。</p>
<p>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p>
<p><img data-src="https://uploadfiles.nowcoder.com/images/20180927/308572_1538031730696_9D37F61D193E7D36552FD03117135AE8" alt="img"></p>
<h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>建立在归并操作上的一种有效的排序算法。采用分治法。</p>
<h2 id="冒泡排序的原理"><a href="#冒泡排序的原理" class="headerlink" title="冒泡排序的原理"></a>冒泡排序的原理</h2><p>循环比较相邻的两个数，较大的数放在后面</p>
<p><strong>冒泡排序代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mppx(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j+<span class="number">1</span>]&lt;nums[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">                    nums[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        array[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    array=mppx(array);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20200831151301748.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>排序</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法|堆与栈</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E4%B8%8E%E6%A0%88/</url>
    <content><![CDATA[<h2 id="内存中的栈-stack-、堆-heap-和静态区-static-area-的用法"><a href="#内存中的栈-stack-、堆-heap-和静态区-static-area-的用法" class="headerlink" title="内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法"></a>内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。</p>
<a id="more"></a>



<h2 id="heap和stack有什么区别"><a href="#heap和stack有什么区别" class="headerlink" title="heap和stack有什么区别"></a>heap和stack有什么区别</h2><p><strong>heap堆</strong></p>
<p>是一个运行时数据区，类的对象从中分配空间。当new等指令建立，不需要代码显示的释放，由垃圾回收来负责。</p>
<p>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。</p>
<p>缺点：由于其优点，所以存取速度较慢。</p>
<p><strong>stack栈</strong></p>
<p>数据项插入和删除都只能在称为栈顶的一端完成，先进先出。栈中存放一些基本类型的变量和对象句柄。</p>
<p>优点：读取数据比堆块，仅次于寄存器，栈数据可以共享。</p>
<p>缺点：缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>堆与栈</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>堆与栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法|树</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
    <content><![CDATA[<p>链表和数组是线性存储结构。树结构是非线性存储结构。存储的是具有“一对多”关系的数据元素的集合。、</p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS0094003158.png" alt="img"></p>
<pre><code>                                                                              (A)                                                                     (B) </code></pre>
<a id="more"></a>

<p>（A）是使用树结构存储的集合{A,B,C,D,E,F,G, H,I,J,K,L,M}，对于数据A来说，和数据B、C、D有关系，对于数据B来说，和数据E、F有关系。这就是一对多的关系。</p>
<p>（B）很像实际生活中的树倒过来，所以称之为“树形存储结构”。</p>
<h2 id="树的结点"><a href="#树的结点" class="headerlink" title="树的结点"></a>树的结点</h2><p>结点：使用树结构存储的每一个数据元素都被称为“结点”</p>
<p>父结点：A是BCD的父节点</p>
<p>子结点：BCD是A的子节点</p>
<p>兄弟结点：KL是兄弟结点，EF是兄弟结点，HIJ是兄弟结点，BCD是兄弟结点</p>
<p>（树）根结点：（A）中的A元素是根结点</p>
<p>叶（子）结点：没有任何子结点的结点成为叶子结点，（A）中的KLFGIJM是叶结点。</p>
<h2 id="子树和空树"><a href="#子树和空树" class="headerlink" title="子树和空树"></a>子树和空树</h2><p>子树：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>
<p>空树：空树中没有结点。</p>
<h2 id="结点的度和层次"><a href="#结点的度和层次" class="headerlink" title="结点的度和层次"></a>结点的度和层次</h2><p>结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度。</p>
<p>​                    一棵树的度是树内各结点的度的最大值，（A）树的度是3</p>
<p>结点的层次：一棵树的深度（高度）是树中结点所在的最大的层次，（A）树的深度是4.</p>
<h2 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h2><p>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</p>
<p>在有序树中，一个结点最左边的子树称为”第一个孩子”，最右边的称为”最后一个孩子”。</p>
<p>在（A）中，如果本身是一颗有序树，则以结点B为根结点的子树为整棵树的第一个孩子，以结点D为根结点的子树为整棵树的最后一个孩子。</p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p>
<h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><p>嵌套集合、凹入表示法、广义表。</p>
<hr>
<h2 id="二叉树和二叉树的性质"><a href="#二叉树和二叉树的性质" class="headerlink" title="二叉树和二叉树的性质"></a>二叉树和二叉树的性质</h2><p><strong>二叉树：</strong></p>
<p>1.本身是有序树。</p>
<p>2.树中包含的各个结点的度不能超过2，即只能是0，1或者2.</p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195I0M1.gif" alt="二叉树示意图"></p>
<p>图a)是一颗二叉树，图b)不是。</p>
<p><strong>性质：</strong><br>$$<br>1.二叉树中，第 i 层最多有2^i-1 个结点。<br>$$</p>
<p>$$<br>2.如果二叉树的深度为 K，那么此二叉树最多有 2^K-1个结点。<br>$$</p>
<p>$$<br>3.二叉树中，终端结点数（叶子结点数）为 n_0，度为 2 的结点数为 n_2，则 n_0=n_2+1。<br>$$</p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif" alt="满二叉树示意图"></p>
<p><strong>性质：</strong><br>$$<br>具有 n 个节点的满二叉树的深度为 log_2(n+1)。<br>$$</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif" alt="完全二叉树示意图"></p>
<h2 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h2><p><strong>二叉树转完全二叉树</strong></p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS01056261L.png" alt="img"></p>
<p>图 1 中，左侧是普通二叉树，右侧是转化后的完全（满）二叉树。</p>
<p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</p>
<p>由普通二叉树转换来的完全二叉树。</p>
<p><img data-src="http://data.biancheng.net/uploads/allimg/170830/2-1FS0105A9146.png" alt="img"></p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>先序遍历</p>
<ol>
<li>访问根结点；</li>
<li>访问当前结点的左子树；</li>
<li>若当前结点无左子树，则访问当前节点的右子树。</li>
</ol>
<p>中序遍历</p>
<ol>
<li>访问当前结点的左子树；</li>
<li>访问根结点；</li>
<li>访问当前结点的右子树。</li>
</ol>
<p>后续遍历</p>
<ol>
<li>访问当前结点的左子树；</li>
<li>访问当前结点的右子树；</li>
<li>访问当前结点的根结点。</li>
</ol>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>树</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法|链表</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><p>1.增加/删除/修改速度比数组快。</p>
<p>2.查找速度慢，查找时，需要循环链表访问。</p>
<p>3.如果进行<strong>频繁</strong>插入和删除操作，会导致速度很慢。</p>
<a id="more"></a>



<h2 id="链表实现代码"><a href="#链表实现代码" class="headerlink" title="链表实现代码"></a>链表实现代码</h2><p><strong>导包：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<p><strong>定义节点类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    ListNode()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带val的构造方法</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印链表：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(pHead.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        pHead=pHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除节点：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">     ListNode p = pHead;</span><br><span class="line">     <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//删除头结点</span></span><br><span class="line">         p=p.next;</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         p=p.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     p.next=p.next.next;</span><br><span class="line">     <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>增加节点：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">     ListNode q = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">     <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//在头结点前插入</span></span><br><span class="line">         q.next=pHead;</span><br><span class="line">         <span class="keyword">return</span> q;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode p = pHead;</span><br><span class="line">     <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             p=p.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">     q.next=p.next;</span><br><span class="line">     p.next=q;</span><br><span class="line">     <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">createListNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点值以-1结束&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ListNode pHead= <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>((temp=scan.nextInt())==-<span class="number">1</span>)&#123;<span class="comment">//头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead.val=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p =pHead;</span><br><span class="line">        <span class="keyword">while</span>((temp=scan.nextInt())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode q = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            p.next=q;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(pHead.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            pHead=pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在某位置增加一个节点，pos=0表示在头结点前插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        ListNode q = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//在头结点前插入</span></span><br><span class="line">            q.next=pHead;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        q.next=p.next;</span><br><span class="line">        p.next=q;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除某个节点,pos=0,表示删除头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode pHead,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;<span class="comment">//删除头结点</span></span><br><span class="line">            p=p.next;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((--pos)&gt;<span class="number">0</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=p.next.next;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除排序后的重复节点(重复节点只留一个)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteReNode</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.val==p.next.val)&#123;</span><br><span class="line">                p.next=p.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除排序后的重复节点(重复节点都删除)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteReNodeAll</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        ListNode p = pHead;<span class="comment">//链表遍历指针</span></span><br><span class="line">        ListNode newHead=<span class="keyword">new</span> ListNode();<span class="comment">//用于存放不重复节点</span></span><br><span class="line">        ListNode q=newHead;<span class="comment">//新链表的构建指针</span></span><br><span class="line">        ListNode pre=p;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.val==p.next.val)&#123;<span class="comment">//如果当前节点后下一个节点相同，则p往后移</span></span><br><span class="line">                p=p.next;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>)&#123;<span class="comment">//如果当前节点的值和后一节点的值不同，则当前节点是有可能不是重复节点，判断pre是否等于p</span></span><br><span class="line">                <span class="keyword">if</span>(pre==p)&#123;<span class="comment">//如果pre==p,说明p当前节点不是重复节点，则将该节点加入newHead中</span></span><br><span class="line">                    q.next=<span class="keyword">new</span> ListNode(p.val);</span><br><span class="line">                    q=q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=p.next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果p.next为null</span></span><br><span class="line">                <span class="keyword">if</span>(p==pre)&#123;</span><br><span class="line">                    q.next=<span class="keyword">new</span> ListNode(pre.val);</span><br><span class="line">                    q=q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main op = <span class="keyword">new</span> Main();</span><br><span class="line">        ListNode pHead =  <span class="keyword">new</span> ListNode();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建链表&quot;</span>);</span><br><span class="line">        pHead=op.createListNode();</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;链表pos处增加节点&quot;</span>);</span><br><span class="line">        pHead=op.addNode(pHead, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表pos处节点&quot;</span>);</span><br><span class="line">        pHead=op.deleteNode(pHead, <span class="number">2</span>);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表的重复值，但是保留一个&quot;</span>);</span><br><span class="line">        op.deleteReNode(pHead);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除链表的重复值&quot;</span>);</span><br><span class="line">        pHead=op.deleteReNodeAll(pHead);</span><br><span class="line">        op.display(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img data-src="https://img-blog.csdnimg.cn/20200831103309462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>链表</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法|高级算法</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="id全局唯一且自增，如何实现"><a href="#id全局唯一且自增，如何实现" class="headerlink" title="id全局唯一且自增，如何实现"></a>id全局唯一且自增，如何实现</h2><p>如何在分布式集群中，生成全局唯一的ID</p>
<p>方法一：UUID</p>
<p>方法二：数据库自增主键</p>
<p><strong>方法三：SnowFlake雪花算法</strong></p>
<p>Twitter公司采用的一种算法，目的是在分布式系统中生成全局唯一且趋势递增的ID。</p>
<p>雪花ID生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成：</p>
<p><img data-src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGovUVwFkfA0yRdCYoer9mqxdkKsBd5aD96r6ygicrXlKjwmsIBCZpF4rrkUM7FR1U1zZdL4yjEF1Fw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<a id="more"></a>

<p><strong>1位标识符</strong>：始终是0，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。</p>
<p><strong>41位时间戳</strong>：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的。</p>
<p><strong>10位机器标识码</strong>：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成。</p>
<p><strong>12位序列</strong>：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号</p>
<p>优点：</p>
<p>1.生成ID不依赖于DB，完全在内存中生成，高性能高可用。</p>
<p>2.ID呈趋势递增，后续插入索引树的时候性能较好。</p>
<p>缺点：</p>
<p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成id冲突，或者id乱序。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>高级算法</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>高级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱</title>
    <url>/2020/09/08/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p><img data-src="https://www.zuozuovera.com/usr/uploads/2017/11/994330753.png" alt="知识图谱.png"></p>
<p><img data-src="https://www.zuozuovera.com/usr/uploads/2017/03/2017-03-20_231425.png" alt="img"></p>
<p><img data-src="https://pic4.zhimg.com/v2-a6e61bbaf7f67c30d9329d28c7872c34_r.jpg" alt="preview"></p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="OSI七层协议模型、TCP-IP四层模型和五层协议体系结构"><a href="#OSI七层协议模型、TCP-IP四层模型和五层协议体系结构" class="headerlink" title="OSI七层协议模型、TCP/IP四层模型和五层协议体系结构"></a>OSI七层协议模型、TCP/IP四层模型和五层协议体系结构</h2><p>OSI七层协议模型：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。</p>
<p>TCP/IP是四层协议模型：网络接口层、<strong>网际层、运输层和应用层。</strong></p>
<p>网络五层模型：物理层、数据链路层、网络层、运输层和应用层。</p>
<a id="more"></a>

<p><strong>1、物理层</strong></p>
<p>主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。</p>
<p><strong>2、数据链路层</strong></p>
<p>定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。</p>
<p><strong>3、网络层</strong></p>
<p>在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p><strong>4、传输层（TCP/UDP）</strong></p>
<p>定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议TCP，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）和UDP（用户数据报协议UDP，与TCP特性恰恰相反，用于传输可靠性要求不高、数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层的接收的数据进行分段和传输，到达目的地后再进行传输。常常把这一层数据叫做段。</p>
<p><strong>5、会话层</strong></p>
<p>通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者就受会话请求（设备之间需要相互认识可以是IP地址也可以是MAC地址或者主机名）。</p>
<p><strong>6、表示层</strong></p>
<p>可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台程序计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。</p>
<p><strong>7、应用层</strong></p>
<p>是最靠近用户的OSI层。这一层为用户的应用程序（如：电子邮件、文件传输和仿真终端）提供网络服务。</p>
<p>​    物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）</p>
<p>​    数据链路层：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）</p>
<p>​    <strong>网络层：</strong>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</p>
<p>​    <strong>传输层：</strong>TCP、UDP、SPX</p>
<p>​    会话层：NFS、SQL、NETBIOS、RPC</p>
<p>​    表示层：JPEG、MPEG、ASII</p>
<p>​    <strong>应用层：</strong>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
<h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p><strong>三次握手</strong></p>
<p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong></p>
<p>1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN(c)**。此时客户端处于 **SYN_Send</strong> 状态。</p>
<p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
<p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
<p>4、服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方就建立起了连接。</p>
<p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据</p>
<p><strong>四次挥手</strong></p>
<p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</p>
<p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</p>
<p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p>
<p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
<p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<h2 id="Http1-1和1-0的区别"><a href="#Http1-1和1-0的区别" class="headerlink" title="Http1.1和1.0的区别"></a>Http1.1和1.0的区别</h2><p><strong>1.缓存处理</strong></p>
<p>http1.0使用header里的if-Modified-Since，Expires来作为缓存的标准。</p>
<p>http1.1引入更多的缓存控制策略Entity tag等。</p>
<p><strong>2.带宽优化及网络连接的使用</strong></p>
<p>http1.0存在浪费带宽的情况，客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</p>
<p>http1.1在请求头引入了range头域，它允许只请求资源的某个部分。</p>
<p><strong>3.错误通知的处理</strong></p>
<p>http1.1新增了24个状态码</p>
<p><strong>4.长连接</strong></p>
<p>http1.1支持长连接和请求的流水线处理。</p>
<h2 id="http请求502和504的区别"><a href="#http请求502和504的区别" class="headerlink" title="http请求502和504的区别"></a>http请求502和504的区别</h2><p>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>
<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>http是明文传输、https是加密的安全传输</p>
<p>连接的端口不一样，http是80，https是443</p>
<p>http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输较安全。</p>
<h2 id="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程"><a href="#浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程" class="headerlink" title="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程"></a>浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</h2><p>1.DNS解析</p>
<p>2.TCP连接 </p>
<p>3.发送HTTP请求 </p>
<p>4.服务器处理请求并返回HTTP报文 </p>
<p>5.浏览器解析渲染页面</p>
<h2 id="负载均衡-反向代理的优点"><a href="#负载均衡-反向代理的优点" class="headerlink" title="负载均衡 反向代理的优点"></a>负载均衡 反向代理的优点</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</p>
<p>拥塞控制</p>
<p>滑动窗口</p>
<p>tcp/udp区别</p>
<p>DNS如何解析</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<h2 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h2><p><strong>1.模型名称</strong></p>
<p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p>
<p><strong>2.问题</strong></p>
<p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p>
<p><strong>3.解决方案</strong></p>
<p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。</p>
<p><strong>4.效果</strong></p>
<p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p>
<a id="more"></a>

<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式一共有<strong>23</strong>个，主要分为三大类。</p>
<p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
<p>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁绣本体建模</title>
    <url>/2020/09/09/%E9%B2%81%E7%BB%A3%E6%9C%AC%E4%BD%93%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h2 id="鲁绣分类（Lu-Embroidery）"><a href="#鲁绣分类（Lu-Embroidery）" class="headerlink" title="鲁绣分类（Lu Embroidery）"></a>鲁绣分类（Lu Embroidery）</h2><table>
<thead>
<tr>
<th align="center">鲁绣品种</th>
<th align="center">产地</th>
</tr>
</thead>
<tbody><tr>
<td align="center">雕平绣工艺</td>
<td align="center">文登</td>
</tr>
<tr>
<td align="center">满工扣锁</td>
<td align="center">文登</td>
</tr>
<tr>
<td align="center">扣眼</td>
<td align="center">乳山</td>
</tr>
<tr>
<td align="center">梭子花边</td>
<td align="center">蓬莱</td>
</tr>
<tr>
<td align="center">棒槌花边</td>
<td align="center">栖霞</td>
</tr>
<tr>
<td align="center">钩针</td>
<td align="center">海阳</td>
</tr>
<tr>
<td align="center">即墨花边</td>
<td align="center">即墨</td>
</tr>
<tr>
<td align="center">网扣</td>
<td align="center">招远</td>
</tr>
<tr>
<td align="center">花边</td>
<td align="center">青州</td>
</tr>
<tr>
<td align="center">发丝绣</td>
<td align="center">济南</td>
</tr>
</tbody></table>
<a id="more"></a>



<h2 id="图案分类（Pattern）"><a href="#图案分类（Pattern）" class="headerlink" title="图案分类（Pattern）"></a>图案分类（Pattern）</h2><table>
<thead>
<tr>
<th align="center">类别名称</th>
<th align="center">包含图案</th>
</tr>
</thead>
<tbody><tr>
<td align="center">植物类</td>
<td align="center">梅、兰、菊、桃花、牡丹、荷花、花卉等花卉；竹子、松树、柳树、石榴、佛手、桃树</td>
</tr>
<tr>
<td align="center">动物类</td>
<td align="center">蝴蝶、蜻蜓等昆虫；凤凰、孔雀、鸳鸯、喜鹊等鸟类；熊猫、鹿、金鱼等动物在鲁绣上的运用</td>
</tr>
<tr>
<td align="center">几何图案</td>
<td align="center">运用点、线、面等元素组合成十字、方格、菱形等几何形，加之色彩的疏密组合表现，画面丰满、自由</td>
</tr>
<tr>
<td align="center">文字图案</td>
<td align="center">用字直抒胸臆</td>
</tr>
</tbody></table>
<h2 id="组织形式（Form）"><a href="#组织形式（Form）" class="headerlink" title="组织形式（Form）"></a>组织形式（Form）</h2><table>
<thead>
<tr>
<th align="center">Form_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单独纹样</td>
</tr>
<tr>
<td align="center">适合图案</td>
</tr>
<tr>
<td align="center">连续图案</td>
</tr>
<tr>
<td align="center">综合图案</td>
</tr>
</tbody></table>
<h2 id="布的种类（Cloth）"><a href="#布的种类（Cloth）" class="headerlink" title="布的种类（Cloth）"></a>布的种类（Cloth）</h2><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">植物纤维布</td>
<td align="center">植物纤维布是各种纯棉、麻和棉麻交织布。一般棉纱做台布用21支纱布幅36、54、72英寸。后来做床上用品使用30、40、60、支纱等交织和斜纹布，布幅都是90英寸以上，布料细腻柔软。鲁绣雕平绣工艺用料多一些。</td>
</tr>
<tr>
<td align="center">动物纤维布</td>
<td align="center">动物纤维布包括丝绸、软缎、乔其纱、羊绒、法兰绒、纯毛呢料等。蜀绣、苏绣平绣多一些。</td>
</tr>
<tr>
<td align="center">化纤布</td>
<td align="center">化纤布不像棉麻毛质材料耐高温，选着绣花时绣线最好不用棉、丝线刺绣。适合做机绣、丝带绣、金银线盘肠绣、主修、亮片绣等。</td>
</tr>
<tr>
<td align="center">玻璃砂</td>
<td align="center">玻璃纱适合发绣、丝线绣、乱针绣、双面绣等。</td>
</tr>
</tbody></table>
<h2 id="绣线种类（Thread）"><a href="#绣线种类（Thread）" class="headerlink" title="绣线种类（Thread）"></a>绣线种类（Thread）</h2><table>
<thead>
<tr>
<th align="center">绣线种类Thread</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">纯棉细线</td>
<td align="center">用线通常40多个色系，每个色系6—9个色阶。40支纱2股，30支纱2股</td>
</tr>
<tr>
<td align="center">纯棉粗线</td>
<td align="center">通常为20或21支纱3股或4股。20/4、21/4有的是丝光了手绣线用作雕绣、平绣等。</td>
</tr>
<tr>
<td align="center">合股线</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">麻线</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">真丝线</td>
<td align="center">是中国南方独有的，只有中国才有。适合绣动物、花鸟效果极佳。</td>
</tr>
<tr>
<td align="center">机绣线</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">毛线</td>
<td align="center">一般用在钩针、毛线绣、织毛衣用。有细毛线、粗毛线。用于绣花一般底布要厚实一些为好</td>
</tr>
<tr>
<td align="center">金银线</td>
<td align="center">一般适合做盘金绣，金银线质地比较脆，他不适宜做复杂图案。</td>
</tr>
<tr>
<td align="center">化纤线</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="绣花工具（Tool）"><a href="#绣花工具（Tool）" class="headerlink" title="绣花工具（Tool）"></a>绣花工具（Tool）</h2><table>
<thead>
<tr>
<th align="center">绣花工具Tool</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">针</td>
<td align="center">针鼻椭圆形，针尖越细越好</td>
</tr>
<tr>
<td align="center">剪刀</td>
<td align="center">弯头剪刀，直头剪刀</td>
</tr>
<tr>
<td align="center">花绷子</td>
<td align="center">方形、圆形；木制、竹制、塑料材质；大中小。圆形的花绷子有竹制和塑料的两种。</td>
</tr>
</tbody></table>
<p>圆形大号竹制、圆形中号竹制、圆形小号竹制、圆形大号塑料、圆形中号塑料、圆形小号塑料</p>
<p>方形大号木制、方形中号木制、方形小号木制、方形大号竹制、方形中号竹制、方形小号竹制</p>
<p>方形大号塑料、方形中号塑料、方形小号塑料</p>
<h2 id="刺绣针法（Stitch）"><a href="#刺绣针法（Stitch）" class="headerlink" title="刺绣针法（Stitch）"></a>刺绣针法（Stitch）</h2><table>
<thead>
<tr>
<th align="center">所属大类</th>
<th align="center">针法种类</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>线性</strong></td>
<td align="center">单针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">双针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">锁链绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">麦穗绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">盘金绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">绗针绣</td>
</tr>
<tr>
<td align="center"><strong>花形</strong></td>
<td align="center">平针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">掺针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">垫绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">雕绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">长短针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">套针</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">结子花绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">影绣花</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">扒针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">圈边绣</td>
</tr>
<tr>
<td align="center"><strong>叶子</strong></td>
<td align="center">单边水绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">双边水绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">松针绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">散套叶绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">编叶绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">树叶绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">水草绣</td>
</tr>
<tr>
<td align="center"><strong>开光纹样和花蕊</strong></td>
<td align="center">把锦绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">连锦绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">钱眼纹绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">席纹绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">瓦楞纹绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">纳底纹绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">打籽绣</td>
</tr>
<tr>
<td align="center"><strong>大面积的针法</strong></td>
<td align="center">直短针绣小乱针</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">直长针绣大乱针</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">直针绣长乱针</td>
</tr>
<tr>
<td align="center"><strong>补绣</strong></td>
<td align="center">绣补</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">扦补绣</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">锁补绣</td>
</tr>
</tbody></table>
<h2 id="三元组"><a href="#三元组" class="headerlink" title="三元组"></a>三元组</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909163912239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Protege构建结果"><a href="#Protege构建结果" class="headerlink" title="Protégé构建结果"></a>Protégé构建结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909163331396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="知识服务平台构建结果"><a href="#知识服务平台构建结果" class="headerlink" title="知识服务平台构建结果"></a>知识服务平台构建结果</h2><p><img data-src="https://img-blog.csdnimg.cn/20200909164509190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>本体建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE基础|Java基础和关键字</title>
    <url>/2020/08/26/Java-SE%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Java%E5%9F%BA%E7%A1%80%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><img data-src="https://uploadfiles.nowcoder.com/images/20180914/826546_1536916757441_FF474C03D9D513A3519773CB35561940" alt="Java基础"></p>
<h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><h2 id="1-Java特性"><a href="#1-Java特性" class="headerlink" title="1.Java特性"></a>1.Java特性</h2><p>Java做为一门“全面”面向对象的编程语言，提供了面向对象的<strong>四种基本性质：抽象性、封装性、继承性和多态性</strong>。 面向对象主要有四大特性：<strong>封装、抽象、继承和多态</strong>。</p>
<p>Java支持8种数据类型：</p>
<p>byte—————&gt;Byte<br>short—————&gt;Short<br>int——————&gt;Integer<br>long——————&gt;Long<br>float——————&gt;Float<br>double——————&gt;Double<br>boolean——————&gt;Boolean<br>char——————&gt;Character</p>
<a id="more"></a>



<h2 id="2-Java如何支持正则表达式"><a href="#2-Java如何支持正则表达式" class="headerlink" title="2.Java如何支持正则表达式"></a>2.Java如何支持正则表达式</h2><p>Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>返回结果是：成都市</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200827164545555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="正则表达式匹配规则(1)"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200827164616859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="正则表达式匹配规则(2)"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200827164632485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3premJoaA==,size_16,color_FFFFFF,t_70#pic_center" alt="正则表达式匹配规则(3)"></p>
<h2 id="3-正则表达式及其用途"><a href="#3-正则表达式及其用途" class="headerlink" title="3.正则表达式及其用途"></a>3.正则表达式及其用途</h2><p>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p>
<h2 id="4-Java和JavaScript"><a href="#4-Java和JavaScript" class="headerlink" title="4.Java和JavaScript"></a>4.Java和JavaScript</h2><p>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言.</p>
<p>一、基于对象和面向对象</p>
<p>Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</p>
<p>二、解释和编译</p>
<p>Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。目前浏览器几乎都是用了JIT，即时编译。</p>
<p>三、强类型变量和类型弱变量</p>
<p>Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，<strong>JavaScript的解释器在运行时检查推断其数据类型</strong></p>
<p>四、代码格式不同</p>
<h2 id="5-Java如何跳出循环"><a href="#5-Java如何跳出循环" class="headerlink" title="5.Java如何跳出循环"></a>5.Java如何跳出循环</h2><p>考察循环</p>
<p>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。Java中支持带标签的break和continue语句。应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用。使用需<strong>谨慎</strong></p>
<h2 id="6-amp-和-amp-amp-的区别"><a href="#6-amp-和-amp-amp-的区别" class="headerlink" title="6.&amp;和&amp;&amp;的区别"></a>6.&amp;和&amp;&amp;的区别</h2><p>考察运算符</p>
<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<p>&amp;&amp;运算符是短路与运算</p>
<p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，<strong>二者的顺序不能交换</strong>，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则<strong>会产生NullPointerException异常。</strong></p>
<h2 id="7-int和Integer有什么区别"><a href="#7-int和Integer有什么区别" class="headerlink" title="7.int和Integer有什么区别"></a>7.int和Integer有什么区别</h2><p>考察数据类型</p>
<p><strong>Int是java的原始数据类型，Integer是java为int提供的封装类。</strong></p>
<p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<strong>但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型</strong>（wrapper class），int的包装类就是Integer，从Java 5开始引入了<strong>自动装箱/拆箱机制</strong>，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br>- 原始类型: boolean，char，byte，short，int，long，float，double<br>- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<hr>
<h2 id="8-Array和ArrayList的区别"><a href="#8-Array和ArrayList的区别" class="headerlink" title="8.Array和ArrayList的区别"></a>8.Array和ArrayList的区别</h2><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。<br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<h2 id="9-值传递和引用传递"><a href="#9-值传递和引用传递" class="headerlink" title="9.值传递和引用传递"></a>9.值传递和引用传递</h2><p>考察：Java引用传递</p>
<p>值传递：传递的是该变量的一个副本,改变副本不影响原变量。</p>
<p>引用传递：对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。<strong>对引用对象进行操作会同时改变原对象</strong></p>
<p><strong>一般认为,java内的传递都是值传递.</strong></p>
<h2 id="10-Lamda表达式是什么？优缺点。"><a href="#10-Lamda表达式是什么？优缺点。" class="headerlink" title="10.Lamda表达式是什么？优缺点。"></a>10.Lamda表达式是什么？优缺点。</h2><p>Lambda表达式是Java SE 8中一个重要的新特性，lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体。</p>
<p>Lambda表达式还增强了<strong>集合库</strong>。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及 java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化</p>
<p><strong>Lambda表达式的语法</strong><br>基本语法:<br><strong>(parameters) -&gt; expression</strong><br>或<br>**(parameters) -&gt;{ statements;** </p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> &#123;</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">String</span>[] atp = &#123;<span class="string">&quot;Rafael Nadal&quot;</span>, <span class="string">&quot;Novak Djokovic&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Stanislas Wawrinka&quot;</span>,</span><br><span class="line">                <span class="string">&quot;David Ferrer&quot;</span>,<span class="string">&quot;Roger Federer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Andy Murray&quot;</span>,<span class="string">&quot;Tomas Berdych&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Juan Martin Del Potro&quot;</span>&#125;;</span><br><span class="line">        List&lt;<span class="built_in">String</span>&gt; players= Arrays.asList(atp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> player : players) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(player + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        players.forEach<span class="function"><span class="params">((player) -&gt; System.out.<span class="built_in">print</span>(player + <span class="string">&quot;; &quot;</span>))</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>



<p>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</p>
<p>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p>
<h2 id="11-Map的分类"><a href="#11-Map的分类" class="headerlink" title="11.Map的分类"></a>11.Map的分类</h2><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<p>java.util.Map；有四个实现类</p>
<p>HashMap Hashtable LinkedHashMap和TreeMap</p>
<p><strong>HashMap</strong>是一个最常用的Map，根据键值可以直接获取它的值只允许一条记录的键为Null；允许多条记录的值为Null；不支持线程的同步。</p>
<p><strong>Hashtable</strong>与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<p><strong>LinkedHashMap</strong> 是HashMap的一个子类，保存了记录的插入顺序。</p>
<p><strong>TreeMap</strong>实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<hr>
<h1 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h1><h2 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1.访问控制"></a>1.访问控制</h2><p><strong>1.private私有的</strong></p>
<p>private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。在类的外部或者对于子类而言，它们是不可见的。</p>
<p><strong>2.protected受保护的</strong></p>
<p>protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段</p>
<p><strong>3.public公有的</strong></p>
<p>public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 可能只会在其他任何类或包中引用 public 类、方法或字段。</p>
<p><img data-src="C:\Users\hit_zhangkai\AppData\Roaming\Typora\typora-user-images\image-20200826185120931.png" alt="image-20200826185120931"></p>
<h2 id="2-类、方法和变量修饰符"><a href="#2-类、方法和变量修饰符" class="headerlink" title="2.类、方法和变量修饰符"></a>2.类、方法和变量修饰符</h2><p><strong>1.abstract声明抽象</strong></p>
<p>abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。</p>
<p><strong>2.class类</strong></p>
<p>class 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体。要使用类，通常使用 new 操作符将类的对象实例化，然后调用类的方法来访问类的功能。</p>
<p><strong>3.extends继承、扩展</strong></p>
<p>extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。</p>
<p>子类可以重写父类的任何非 final 方法。一个类只能扩展一个其他类。</p>
<p><strong>4.final最终，不可改变</strong></p>
<p>final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。final方法在编译阶段绑定，称为静态绑定(static binding)。</p>
<p><strong>5.implements实现</strong></p>
<p>implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现</p>
<p><strong>6.interface接口</strong></p>
<p>interface 关键字用来声明新的 Java 接口，接口是方法的集合</p>
<p><strong>7.native本地</strong></p>
<p>本地方法</p>
<p>为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用JAVA编写的。</p>
<p>为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。</p>
<p><strong>8.new</strong></p>
<p>new 关键字用于创建类的新实例。</p>
<p>new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。 参数集合必须与类的构造方法的签名匹配。</p>
<p><strong>9.static静态</strong></p>
<p>static可以用于修饰属性，可以修饰代码块，也可以用于修饰方法，还可以用于修饰类。</p>
<p>1、static修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态的成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也会随之发生变化。如果一个成员变量是static的，那么我们可以通过‘类名.成员变量名’的方式来使用它。</p>
<p>2、static修饰方法：static修饰的方法叫做静态方法。对于静态方法来说，可以使用‘类名.方法名’的方式来访问。静态方法只能继承，不能重写（Override），因为重写是用于表现多态的，重写只能适用于实例方法，而静态方法是可以不生成实例直接用类名来调用，这就会与重写的定义所冲突，与多态所冲突，所以静态方法不能重写，只能是隐藏。</p>
<p>3、static修饰代码块：静态代码块。静态代码块的作用也是完成一些初始化工作。<strong>首先执行静态代码块，然后执行构造方法。</strong>静态代码块在类被加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到Java虚拟机上（JVM），然后由JVM加载这个类来生成对象。</p>
<p>4、static修饰类：这个有点特殊，首先，static是可以用来修饰类的，但是static是不允许用来修饰普通类，只能用来修饰内部类，被static所修饰的内部类可以用new关键字来直接创建一个实例，不需要先创建外部类实例。static内部类可以被其他类实例化和引用（即使它是顶级类）。</p>
<p><strong>10.strictfp严格，精准</strong></p>
<p>strictfp的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。</p>
<p><strong>11.synchronized线程、同步</strong></p>
<p>synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。</p>
<p>synchronized 关键字可防止代码的关键代码段一次被多个线程执行。如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。</p>
<p><strong>12.transient短暂</strong></p>
<p>transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。</p>
<p><strong>13.volatitle易失</strong></p>
<p>volatile 关键字用于表示可以被多个线程异步修改的成员变量。</p>
<h2 id="3-程序控制语句"><a href="#3-程序控制语句" class="headerlink" title="3.程序控制语句"></a>3.程序控制语句</h2><p><strong>1.brask跳出，中断</strong></p>
<p>break 关键字用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。</p>
<p><strong>2.continue继续</strong></p>
<p>continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。</p>
<p>continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。</p>
<p><strong>3.return返回</strong></p>
<p>return 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值</p>
<p><strong>4.do运行</strong></p>
<p>do 关键字用于指定一个在每次迭代结束时检查其条件的循环。</p>
<p>do 循环体至少执行一次。 条件表达式后面必须有分号。</p>
<p><strong>5.while循环</strong></p>
<p>while 关键字用于指定一个只要条件为真就会重复的循环。</p>
<p><strong>6.if如果</strong></p>
<p>if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。</p>
<p>if 语句可以有可选的 else 子句，该子句包含条件为 false 时将执行的代码。</p>
<p>包含 boolean 操作数的表达式只能包含 boolean 操作数。</p>
<p><strong>7.else否则</strong></p>
<p>else 关键字总是在 if-else 语句中与 if 关键字结合使用。else 子句是可选的，如果 if 条件为 false，则执行该子句。</p>
<p><strong>8.for循环</strong></p>
<p>or 关键字用于指定一个在每次迭代结束前检查其条件的循环。</p>
<p><strong>9.instanceof实例</strong></p>
<p>instanceof 关键字用来确定对象所属的类。</p>
<p><strong>10switch观察</strong></p>
<p>switch 语句用于基于某个表达式选择执行多个代码块中的某一个。</p>
<p>switch 条件的计算结果必须等于 byte、char、short 或 int。</p>
<p>case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。</p>
<p><strong>11.case返回观察里的结果</strong></p>
<p>case 用来标记 switch 语句中的每个分支。</p>
<p>case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。</p>
<p>如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。</p>
<p><strong>12.default默认</strong></p>
<p>default 关键字用来标记 switch 语句中的默认分支。</p>
<p>default 块没有隐式结束点。break 语句通常在每个 case 或 default 块的末尾使用，以便在完成块时退出 switch 语句。</p>
<p>如果没有 default 语句，其参数与任何 case 块都不匹配的 switch 语句将不执行任何操作。</p>
<h2 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h2><p><strong>1.try捕获异常</strong></p>
<p>try 关键字用于包含可能引发异常的语句块。</p>
<p>每个 try 块都必须至少有一个 catch 或 finally 子句。</p>
<p><strong>2.catch处理异常</strong></p>
<p>catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块。</p>
<p><strong>3.throw派出一个异常对象</strong></p>
<p>throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。</p>
<p><strong>4.throws 声明一个异常可能被抛出</strong></p>
<p>throws 关键字可以应用于方法，以便指出方法引发了特定类型的异常。</p>
<p>throws 关键字将逗号分隔的 java.lang.Throwables 列表作为参数。</p>
<p><strong>5.finally</strong></p>
<p>在异常处理机制当中，它的作用就像是人吃饭一样，必须得做的，不论有异常还是没有异常都要执行的代码就可以放到finally块当中去。finally块，必须要配合try块一起使用，不能单独使用，也不能直接和catch块一起使用。</p>
<p>finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。</p>
<p>finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行</p>
<h2 id="5-包相关"><a href="#5-包相关" class="headerlink" title="5.包相关"></a>5.包相关</h2><p><strong>1.import导入</strong></p>
<p>import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。</p>
<p>当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。</p>
<p><strong>2.package包</strong></p>
<p>package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。</p>
<h2 id="6-基本类型"><a href="#6-基本类型" class="headerlink" title="6.基本类型"></a>6.基本类型</h2><p><strong>1.boolean布尔型</strong></p>
<p>boolean 是 Java 原始类型。boolean 变量的值可以是 true 或 false。</p>
<p><strong>2.byte字节型</strong></p>
<p>byte 是 Java 原始类型。byte 可存储在 [-128, 127] 范围以内的整数值。</p>
<p><strong>3.char字符型</strong></p>
<p>char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。</p>
<p><strong>4.double双精度</strong></p>
<p>double 是 Java 原始类型。double 变量可以存储双精度浮点值。</p>
<p>由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。</p>
<p><strong>5.float浮点</strong></p>
<p>float 是 Java 原始类型。float 变量可以存储单精度浮点值。</p>
<p>使用此关键字时应遵循下列规则：</p>
<p>Java 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 f 或 F，如 0.01f。</p>
<p><strong>6.int整形</strong></p>
<p>int 是 Java 原始类型。int 变量可以存储 32 位的整数值。</p>
<p><strong>7.long长整形</strong></p>
<p>long 是 Java 原始类型。long 变量可以存储 64 位的带符号整数。</p>
<p>Long 类是 long 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。</p>
<p>Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。</p>
<p><strong>8.short短整型</strong></p>
<p>short 是 Java 原始类型。short 变量可以存储 16 位带符号的整数。</p>
<p>Short 类是 short 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。</p>
<p>Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。</p>
<p><strong>9.null空</strong></p>
<p>null 是 Java 的保留字，表示无值。</p>
<p>将 null 赋给非原始变量相当于释放该变量先前所引用的对象。</p>
<p>不能将 null 赋给原始类型（byte、short、int、long、char、float、double、boolean）变量。</p>
<p><strong>10.true真</strong></p>
<p>true 关键字表示 boolean 变量的两个合法值中的一个。</p>
<p><strong>11.false假</strong></p>
<p>false 关键字代表 boolean 变量的两个合法值之一。</p>
<h2 id="7-变量引用"><a href="#7-变量引用" class="headerlink" title="7.变量引用"></a>7.变量引用</h2><p><strong>1.super父类，超类</strong></p>
<p>super 关键字用于引用使用该关键字的类的超类。</p>
<p>作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</p>
<p><strong>2.this本类</strong></p>
<p>this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</p>
<p><strong>3.void无返回值</strong></p>
<p>void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</p>
<h2 id="8-保留字"><a href="#8-保留字" class="headerlink" title="8.保留字"></a>8.保留字</h2><p>保留字是为java预留的关键字，他们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。</p>
<p><strong>1.goto跳转</strong></p>
<p>goto 保留关键字，但无任何作用。结构化程序设计完全不需要 goto 语句即可完成各种流程，而 goto 语句的使用往往会使程序的可读性降低，所以 Java 不允许 goto 跳转。</p>
<p><strong>2.const静态</strong></p>
<p>const 保留字，是一个类型修饰符，使用const声明的对象不能更新。与final某些类似。</p>
]]></content>
      <categories>
        <category>Java面试宝典</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>开题细节</title>
    <url>/2020/09/13/%E5%BC%80%E9%A2%98%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p><strong>第一个研究点是工业领域的本体建模：</strong></p>
<p>工业领域存在一些概念，每种商品都有自己的BOM（物料清单），以服装和鲁绣为例，对BOM进行本体建模。</p>
<p><strong>第二个研究点是工业机理知识图谱的构建：</strong></p>
<p>机理模型本质上是各种经验知识和方法的固化，更多是从业务逻辑原理出发，强调的是因果关系。包含基础理论模型、流程逻辑模型、部件模型、工艺模型、故障模型和仿真模型。在这里，以服装和鲁绣的工艺加工流程为例，构建工业机理知识图谱。</p>
<p><strong>第三个研究点是工业机理知识图谱的知识推理：</strong></p>
<p>有些工艺生产流程半透明，有些潜在的“知识”待发现，主要使用基于Embedding的推理扩展新的三元组，扩充工业机理知识图谱。</p>
<p><strong>第四个研究点是基于工业机理知识图谱的个性化定制：</strong></p>
<p>根据用户的需求或场景，根据图谱个性化推荐一些物品</p>
<p>，用户也可根据推荐的物品对部分进行微调。结合服装生产的BOM和工艺流程，给出个性化定制的方案。</p>
<h2 id="工业领域本体建模"><a href="#工业领域本体建模" class="headerlink" title="工业领域本体建模"></a>工业领域本体建模</h2><p>Step1. 确定本体的领域和范围。</p>
<p>这是本体建模的第一步。明确本体的领域，描述的信息，</p>
<p>Step2. 考虑是否能重用现有本体。</p>
<p>收集和待开发本体相关的其它本体是有价值的。目前网络，上已有一些本体库，从中可以获得很多现有的本体。</p>
<p>Step3. 列出本体中的重要术语。</p>
<p>将所关心的术语列举出来是非常有用的。这些术语大致表明建模过程所感兴趣的事物、物所具有的属性和它们间的关系等。这些重要术语能保证最终创建的本体不会偏离所感兴趣的领域。</p>
<p>Step4. 定义类和类的继承。</p>
<p>类代表着领域内的概念，而类名则是用来指代这些概念。类的命名可以发生变化，但是变化前后都不能和其它类的命名发生冲突。</p>
<p>Step5. 定义属性和关系。</p>
<p>定义类，还需要定义概念和概念间的内部联系。</p>
<p>Step6. 定义属性的限制。</p>
<p>需要进一步定义属性的一些限制，包括属性的基数、属性值的类型，以及属性的定义域和值域。</p>
<p>Step7. 创建实例。</p>
<p>为类创建实例。这需要确定与个体最接近的类，然后添加个体进去作为该类的一个实例，同时要为实例的属性赋值。</p>
<p>Step8. 使用Protégé绘图，生成建模方案。</p>
<p>基于传统的本体构建方案，提出新的本体建模方案，分为概念层和数据层。概念层存工业知识库的概念信息。数据层存数据信息。IOM（Industrial Ontology Modeling）是一个五元组：工业领域的概念；工业领域的类；工业领域的关系；工业领域的属性；工业领域的实例以鲁绣为例对本体进行建模，定义好类，关系和属性，如图（a）建模结果见图（b）所示。</p>
<h2 id="工业机理知识图谱的构建"><a href="#工业机理知识图谱的构建" class="headerlink" title="工业机理知识图谱的构建"></a>工业机理知识图谱的构建</h2><p>传统知识图谱构建技术分为自顶向上构建和自底向下的构建方式。</p>
<p>自顶向下构建是指借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库。</p>
<p>自底向上构建，借助一定的技术手段，从公开采集的数据中提取出资源模式，选择执行度较高的新模式，经人工审核后，加入到知识库中。</p>
<p>知识图谱从原始数据出发，采取自动或半自动的技术手段，从原始数据中提取出知识（实体、关系、属性），并将其存储数据层和模式层的过程，这是一个更新迭代的过程。每一轮迭代包含3个阶段：信息抽取、知识融合以及知识加工。</p>
<h2 id="工业机理知识图谱的知识推理"><a href="#工业机理知识图谱的知识推理" class="headerlink" title="工业机理知识图谱的知识推理"></a>工业机理知识图谱的知识推理</h2><p><strong>（1）基于逻辑的推理：</strong></p>
<p>从现有的逻辑规则算法出发，通过已存在的逻辑规则，得出一些隐性的结论。如下公式</p>
<p>队员为队效力</p>
<p>球队参加联赛</p>
<p>推理出：队员参加联赛</p>
<p><strong>（2）基于规则的推理：</strong></p>
<p>预先定义好准确的推理规则，基于这些规则，根据已有的知识推导出新的结论和知识。</p>
<p>衣服1和衣服2有关系1</p>
<p>衣服1和衣服3有关系2</p>
<p>关系1与关系2和关系</p>
<p><strong>（3）基于Embedding的推理</strong></p>
<p>将实体、关系和属性用低维的向量表示，通过有监督或无监督的方式，建模和学习不同元素的表示，可以捕捉到元素之间的隐形联系。知识图谱表示学习旨在将知识图谱中的实体与关系统一映射至连续向量空间中，来刻画它们的潜在语义特征。通过比较实体与关系在该向量空间中的分布式表示，可以推断出实体和实体之间潜在的关系。根据隐形的联系进行推理。</p>
<p>Apache Jena是专门用于语义网本体操作的开源Java框架，其提供RDF和SPARQL API，来查询、修改本体和进行本体推理，并且提供了TDB和Fuseki来存储和管理三元组SPARQL查询：支持查询RDF格式的数据</p>
<p>Step1：配置jena和fuseki的环境</p>
<p>Step2：写推导规则（rules.ttl）每条规则需要使用逗号隔开</p>
<p>Step3：配置问题。查阅fuseki的官网，重写配置文件fuseki_confi.ttl。</p>
<p>Step4：对于简单的推导，不需要自定义推导规则，直接使用OWLFBRuleReasoner即可。</p>
<p>Step5：使用SPARQL进行查询。</p>
<h2 id="基于工业机理知识图谱的个性化定制"><a href="#基于工业机理知识图谱的个性化定制" class="headerlink" title="基于工业机理知识图谱的个性化定制"></a>基于工业机理知识图谱的个性化定制</h2><p>Step1：根据用户的需求，结合命名实体识别方法（NER），提取出“关键词”。</p>
<p>NER系统就是从非结构化的输入文本中抽取出上述实体，并且可以按照业务需求识别出更多类别的实体。NER的命名实体包含3大类（实体类，时间类，数字类）和7小类（人名、地名、组织机构名、时间、日期、货币、百分比）。</p>
<p>Step2：根据关键词检索构工业机理知识图谱，提取出满足关键词的商品。</p>
<p>Step3：为用户推荐满足的实例。</p>
<p>Step4：检索商品包含的面辅料、图案等，为用户推荐。</p>
<p>Step5：用户根据推荐的同款商品，不同的图案和面辅料，进行个性化选择。</p>
<p>Step6：用户选择完毕后，结合知识图谱返回对应的物料BOM和工艺流程，计算价格。</p>
]]></content>
  </entry>
</search>
